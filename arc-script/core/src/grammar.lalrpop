use {
  crate::prelude::*,
  crate::parser::*,
  std::collections::HashMap,
  lalrpop_util::ErrorRecovery,
  chrono::Duration,
};

//=============================================================================
// Grammar
//=============================================================================

grammar<'a>(
  errors: &'a mut Vec<ErrorRecovery<usize, Token<'input>, CompilerError>>,
  taskdefs: &'a mut HashMap<Ident, TaskDef>,
  tydefs: &'a mut HashMap<Ident, TypeDef>,
  fundefs: &'a mut HashMap<Ident, FunDef>,
  stack: &'a mut SymbolStack,
  table: &'a mut SymbolTable,
  typer: &'a mut Typer,
);

extern {
  type Error = CompilerError;
  type Location = usize;
}

//=============================================================================
// Tokens
//=============================================================================

match {
//=============================================================================
// Grouping
//=============================================================================
  "(",
  ")",
  "{",
  "}",
  "[",
  "]",
  "<{",
  "}>",
//=============================================================================
// Operators
//=============================================================================
  "+",
  "-",
  "*",
  "/",
  "!",
  ":",
  "?",
  "=",
  "==",
  "!=",
  ">",
  "<",
  ">=",
  "<=",
  "=>",
  "|",
  "::",
  "|>",
  "<-",
  "||",
  "&&",
  ",",
  ";",
  ".",
//=============================================================================
// Keywords
//=============================================================================
  "_",
  "let",
  "if",
  "then",
  "else",
  "in",
  "of",
  "fold",
  "fmap",
  "imap",
  "fun",
  "task",
  "end",
  "as",
  "match",
  "type",
  "source",
  "sink",
  "loop",
//=============================================================================
// Types
//=============================================================================
  "i8",
  "i16",
  "i32",
  "i64",
  "f32",
  "f64",
  "bool",
  "str",
  "null",
  "json",
  "csv",
  "dataset",
} else {
//=============================================================================
// Decimal
//=============================================================================
  r"[0-9]+i8"                                                   => TI8Base10,
  r"[0-9]+i16"                                                  => TI16Base10,
  r"[0-9]+i64"                                                  => TI64Base10,
  r"(([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+))f32"  => TF32Base10,
//=============================================================================
// Binary
//=============================================================================
  r"0b[0-1]+i8"                                                 => TI8Base2,
  r"0b[0-1]+i16"                                                => TI16Base2,
  r"0b[0-1]+i64"                                                => TI64Base2,
//=============================================================================
// Hexadecimal
//=============================================================================
  r"0x[0-9a-fA-F]+i8"                                           => TI8Base16,
  r"0x[0-9a-fA-F]+i16"                                          => TI16Base16,
  r"0x[0-9a-fA-F]+i64"                                          => TI64Base16,
//=============================================================================
// Bool, String
//=============================================================================
  r"true|false"                                                 => TBool,
  r#""[^"]*""#                                                  => TStr,
//=============================================================================
// Regex
//=============================================================================
  r#"r"[^"]*""#                                                 => TRegex,
//=============================================================================
// Syntactic sugar for expressing different units of time
//=============================================================================
  r"[0-9]+s"                                                    => TSec,
  r"[0-9]+us"                                                   => TMSec,
  r"[0-9]+ms"                                                   => TUSec,
  r"[0-9]+ns"                                                   => TNSec,
  r"[0-9]+min"                                                  => TMin,
  r"[0-9]+h"                                                    => THour,
} else {
//=============================================================================
// Non-Postfixed
//=============================================================================
  r"[0-9]+"                                                     => TI32Base10,
  r"0b[0-1]+"                                                   => TI32Base2,
  r"0x[0-9a-fA-F]+"                                             => TI32Base16,
  r"([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+)"       => TF64Base10,
//=============================================================================
// Symbols
//=============================================================================
} else {
  r"\[[0-9]+\]"                                                 => TIndex,
  r"[A-Za-z_][A-Za-z0-9_]*'*"                                   => TSymbol,
} else {
//=============================================================================
// Skip
//=============================================================================
  r"\s*"                                                        => { },
  r"#[^\n\r]*[\n\r]*"                                           => { },
} else {
//=============================================================================
// Drop
//=============================================================================
  r"."                                                          => Undefined,
}

//=============================================================================
// Groups
//=============================================================================

Sep<T, S>:         Vec<T> = <v:(<T> S)*> <e:T?> => v.into_iter().chain(e).collect();
SepNonEmpty<T, S>: Vec<T> = <e:T> <v:(S <T>)*> => vec![e].into_iter().chain(v).collect();
SepMulti<T, S>:    Vec<T> = <e:T> <v:(S <T>)+> => vec![e].into_iter().chain(v).collect();
SepTrailing<T, S>: Vec<T> = (<T> S)*;
Vec<T>:            Vec<T> = Sep<T, ",">;
VecNonEmpty<T>:    Vec<T> = SepNonEmpty<T, ",">;
VecMulti<T>:       Vec<T> = SepMulti<T, ",">;
Semi<T>:           Vec<T> = Sep<T, ";">;
Single<T>:         Vec<T> = T => vec![<>];
Box<T>:            Box<T> = T => Box::new(<>);
Spanned<T>:        Spanned<T> = @L T @R => Spanned(<>);
Paren<T>:          T = "(" <T> ")";

//=============================================================================
// Fields & Variants
//=============================================================================

Field: Field = Spanned<Symbol> => Field::from(<>);

Fields<V>: Map<Field, V> = Vec<(<Field> ":" <V>)> => {
  let mut map = Map::new();
  for (field, val) in <>.into_iter() {
      if map.contains_key(&field) {
        errors.push(
            ErrorRecovery {
                error: ParseError::User {
                    error: CompilerError::DuplicateField { field }
                },
                dropped_tokens: vec![],
            }
        );
      } else {
          map.insert(field, val);
      }
  }
  map
};

Variant: Variant = Spanned<Symbol> => Variant::from(<>);

Variants<V>: Map<Variant, V> = Vec<(<Variant> "of" <V>)> => {
  let mut map = Map::new();
  for (variant, val) in <>.into_iter() {
      if map.contains_key(&variant) {
        errors.push(
            ErrorRecovery {
                error: ParseError::User {
                    error: CompilerError::DuplicateVariant { variant }
                },
                dropped_tokens: vec![],
            }
        );
      } else {
          map.insert(variant, val);
      }
  }
  map
};

//-----------------------------------------------------------------------------
// Operators
//-----------------------------------------------------------------------------

BinaryInfixLeftAssociative<Op, Next>: ExprKind = {
  Box<Expr<BinaryInfixLeftAssociative<Op, Next>>> Op Box<Expr<Next>> => BinOp(<>),
  Next,
};

BinaryInfixRightAssociative<Op, Next>: ExprKind = {
  Box<Expr<Next>> Op Box<Expr<BinaryInfixLeftAssociative<Op, Next>>> => BinOp(<>),
  Next,
};

UnaryPostfix<Op, Next>: ExprKind = {
  <e:Box<Expr<UnaryPostfix<Op, Next>>>> <op:Op> => UnOp(op, e),
  Next,
};

UnaryPrefix<Op, Next>: ExprKind = {
  <op:Op> <e:Box<Expr<UnaryPrefix<Op, Next>>>> => UnOp(op, e),
  Next,
};

//=============================================================================
// Symbols
//=============================================================================

Symbol: SymbolKey = TSymbol => table.intern(<>);

//=============================================================================
// Literals
//=============================================================================

ParseStr: String = TStr => <>[1..<>.len()].to_string();
ParseRegex: CompilerResult<regex::Regex> = Spanned<TRegex> => parse_regex(<>);
ParseBool: CompilerResult<bool> = Spanned<TBool> => parse_lit(<>);

//=============================================================================
// Numerals:
// * parse_lit_radix(<token>, <radix>, <prefix-len>, <suffix-len>)
//=============================================================================

ParseIndex: CompilerResult<Index> = {
  Spanned<TIndex>     => parse_lit_radix(<>, 10, 1, 1).map(Index),
};

ParseF32: CompilerResult<f32> = {
  Spanned<TF32Base10> => parse_lit_radix(<>, 10, 0, 3),
};

ParseF64: CompilerResult<f64> = {
  Spanned<TF64Base10> => parse_lit_radix(<>, 10, 0, 0),
};

ParseI8: CompilerResult<i8> = {
  Spanned<TI8Base10>  => parse_lit_radix(<>, 10, 0, 2),
  Spanned<TI8Base2>   => parse_lit_radix(<>,  2, 2, 2),
  Spanned<TI8Base16>  => parse_lit_radix(<>, 16, 2, 2),
};

ParseI16: CompilerResult<i16> = {
  Spanned<TI16Base10> => parse_lit_radix(<>, 10, 0, 3),
  Spanned<TI16Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI16Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseI32: CompilerResult<i32> = {
  Spanned<TI32Base10> => parse_lit_radix(<>, 10, 0, 0),
  Spanned<TI32Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI32Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseI64: CompilerResult<i64> = {
  Spanned<TI64Base10> => parse_lit_radix(<>, 10, 0, 3),
  Spanned<TI64Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI64Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseTime: CompilerResult<Duration> = {
  Spanned<TSec>       => parse_lit_radix(<>, 10, 0, 3).map(Duration::seconds),
  Spanned<TUSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::microseconds),
  Spanned<TMSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::milliseconds),
  Spanned<TNSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::nanoseconds),
  Spanned<TMin>       => parse_lit_radix(<>, 10, 0, 3).map(Duration::minutes),
  Spanned<THour>      => parse_lit_radix(<>, 10, 0, 1).map(Duration::hours),
};

//=============================================================================
// Non-Terminals
//=============================================================================

pub Script = Def* <Body>;

//=============================================================================
// Definitions
//=============================================================================

Def: () = {
  TaskDef => {
    let (id, taskdef) = <>;
    taskdefs.insert(id, taskdef);
  },
  TypeDef => {
    let (id, tydef) = <>;
    tydefs.insert(id, tydef);
  },
  FunDef => {
    let (id, fundef) = <>;
    fundefs.insert(id, fundef);
  },
};

//=============================================================================
// Name Resolving
//=============================================================================

Params: Vec<Ident> = Vec<Param> => {
  stack.push_scope();
  <>
    .into_iter()
    .map(|(sym, tv)| {
        let id = table.insert(Decl::new(sym, tv, VarDecl));
        stack.bind_local(sym, id);
        id
    })
    .collect::<Vec<_>>()
};

Param = <Symbol> ":" <Type>;

FunDecl: (Ident, Vec<Ident>) = "fun" <Symbol> "(" <Params> ")" => {
  let (sym, param_ids) = (<>);
  let tv = typer.fresh();
  let id = table.insert(Decl::new(sym, tv, FunDecl));
  if let Err(err) = stack.bind_global(sym, id) {
      errors.push(err.into());
  }
  (id, param_ids)
};

FunDef: (Ident, FunDef) = <FunDecl> "{" <Body>  "}" => {
  let ((id, param_ids), body) = (<>);
  stack.pop_scope();
  (id, FunDef::new(param_ids, body))
};

TaskDecl: (Ident, Vec<Ident>) = "task" <Symbol> "(" <Params> ")" => {
  let (sym, param_ids) = (<>);
  let tv = typer.fresh();
  let id = table.insert(Decl::new(sym, tv, TaskDecl(Vec::new())));
  stack.push_scope();
  (id, param_ids)
};

TaskDef: (Ident, TaskDef) = <TaskDecl> "{" <FunDef*> "}" => {
  let ((id, param_ids), fun_defs) = (<>);
  stack.pop_scope();
  (id, TaskDef::new(param_ids, fun_defs.into_iter().collect()))
};

Let: ExprKind = "let" <Symbol> <TypeAnnot> "=" <Box<Arg>> => {
  let (sym, tv, arg) = (<>);
  let id = table.insert(Decl::new(sym, tv, VarDecl));
  stack.bind_local(sym, id);
  Let(id, arg) 
};

Var: ExprKind = <Symbol> => {
  stack.lookup(<>)
       .map(Var)
       .unwrap_or(ExprErr)
};

TypeDef: (Ident, TypeDef) = "type" <Symbol> "=" <Type> => {
  let (sym, tv) = (<>);
  let id = table.insert(Decl::new(sym, tv, TypeDecl));
  if let Err(err) = stack.bind_global(sym, id) {
      errors.push(err.into());
  }
  (id, TypeDef::new(tv))
};

ClosureDecl: Vec<Ident> = "|" <Params> "|";

ClosureDef: ExprKind = <ClosureDecl> <Box<Arg>> => {
  stack.pop_scope();
  Closure(<>)
};


SeqBegin: Box<Expr> = <Box<Stmt>> ";" => {
  let lhs = <>;
  stack.push_scope();
  lhs
};

Seq: ExprKind = SeqBegin Box<Body> => {
  let (lhs, rhs) = (<>);
  stack.pop_scope();
  BinOp(lhs, Seq, rhs)
};

//=============================================================================
// Expressions
//=============================================================================

Body = Expr<ExprKind0>;
Stmt = Expr<ExprKind1>;
Arg  = Expr<ExprKind2>;

Expr<ExprKind>: Expr = Spanned<ExprKind> => Expr::from(<>, typer);

//=============================================================================
// Operators
//=============================================================================

Op0: BinOpKind = {
  "|>" => Pipe,
};

Op1: BinOpKind = {
  "||" => Or,
  "&&" => And,
};

Op2: BinOpKind = {
  "==" => Equ,
  "!=" => Neq,
};

Op3: BinOpKind = {
  ">"  => Gt,
  "<"  => Lt,
  ">=" => Geq,
  "<=" => Leq,
};

Op4: BinOpKind = {
  "+" => Add,
  "-" => Sub,
};

Op5: BinOpKind = {
  "*" => Mul,
  "/" => Div,
};

Op6: UnOpKind = {
  "!" => Not,
  "-" => Neg,
};

Op7: UnOpKind = {
  Call,
  Project,
  Access,
  Cast,
};

Cast:    UnOpKind = "as" <Type>        => Cast(<>);
Access:  UnOpKind = "." <Field>        => Access(<>);
Call:    UnOpKind = "(" <Vec<Arg>> ")" => Call(<>);
Project: UnOpKind = ParseIndex => {
  <>.map(Project)
    .map_err(|err| errors.push(err.into()))
    .unwrap_or(UnOpErr)
};

//=============================================================================
// Keyword operators
//=============================================================================

If:    ExprKind = "if" <Box<Arg>> "{" <Box<Arg>> "}" "else" "{" <Box<Arg>> "}" => If(<>);
Match: ExprKind = "match" <Box<Arg>> "{" <Vec<Case>> "}"                       => Match(<>);
Loop:  ExprKind = "loop" <Box<Arg>> "{" <Box<Arg>> "}"                         => Loop(<>);

//=============================================================================
// Qualifiers
//=============================================================================

Source: ExprKind = "source" "::" <Symbol> => {
  todo!()
  // Source(<>)
};

Sink: ExprKind = "sink" "::" <Symbol> => {
  todo!()
  //  Sink(<>)
};

//=============================================================================
// Cons
//=============================================================================

ConsArray:  ExprKind = "[" <VecNonEmpty<Arg>> "]" => ConsArray(<>);
ConsTuple:  ExprKind = "(" <VecMulti<Arg>> ")"    => ConsTuple(<>);
ConsStruct: ExprKind = "{" <Fields<Arg>> "}"      => ConsStruct(<>);
ConsEnum:   ExprKind = "<{" <Variants<Arg>> "}>"  => ConsEnum(<>);

//=============================================================================
// Precedence Climbing
//=============================================================================

ExprKind0: ExprKind = {
  Seq,
  ExprKind1,
};

ExprKind1: ExprKind = {
  Let,
  ExprKind2,
};

ExprKind2: ExprKind = {
  ClosureDef,
  ExprKind3,
};

ExprKind3:  ExprKind = BinaryInfixLeftAssociative<Op0, ExprKind4>;
ExprKind4:  ExprKind = BinaryInfixLeftAssociative<Op1, ExprKind5>;
ExprKind5:  ExprKind = BinaryInfixLeftAssociative<Op2, ExprKind6>;
ExprKind6:  ExprKind = BinaryInfixLeftAssociative<Op3, ExprKind7>;
ExprKind7:  ExprKind = BinaryInfixLeftAssociative<Op4, ExprKind8>;
ExprKind8:  ExprKind = BinaryInfixLeftAssociative<Op5, ExprKind9>;
ExprKind9:  ExprKind =                UnaryPrefix<Op6, ExprKind10>;
ExprKind10: ExprKind =               UnaryPostfix<Op7, ExprKind11>;

ExprKind11: ExprKind = {
  Paren<ExprKind0>,
  Lit,
  Var,
  ConsArray,
  ConsStruct,
  ConsTuple,
  Sink,
  Source,
  Loop,
  Match,
  If,
  ! => { errors.push(<>.into()); ExprErr },
};

Lit: ExprKind = LitKind => Lit(<>);

LitKind: LitKind = ParseLit => {
  <>.map_err(|err| errors.push(err.into()))
    .unwrap_or(LitErr)
};

ParseLit: CompilerResult<LitKind> = {
  ParseI8   => <>.map(LitI8),
  ParseI16  => <>.map(LitI16),
  ParseI32  => <>.map(LitI32),
  ParseI64  => <>.map(LitI64),
  ParseF32  => <>.map(LitF32),
  ParseF64  => <>.map(LitF64),
  ParseBool => <>.map(LitBool),
  ParseTime => <>.map(LitTime),
};

BIF: BIFKind = {
  "dataset" <Paren<Box<Arg>>>                 => Dataset(<>),
  "fold" <Paren<(<Box<Arg>> "," <Box<Arg>>)>> => Fold(<>.0, <>.1),
  "fmap" <Paren<Box<Arg>>>                    => Fmap(<>),
  "imap" <TypeAnnot> <Paren<Box<Arg>>>        => Imap(<>),
};

//=============================================================================
// Patterns
//=============================================================================

Case = <Clause> "=>" <Body>;

Clause = Pat<PatKind0>;
Leaf   = Pat<PatKind1>;

Pat<PatKind>: Pat = Spanned<PatKind> => Pat::from(<>);

PatKind0: PatKind = {
  PatOr,
  PatKind1
};

PatKind1: PatKind = {
  PatVal,
  //PatVar,
  PatTuple,
  PatIgnore,
};

PatOr: PatKind = <Box<Clause>> "|" <Box<Leaf>> => PatOr(<>);
PatRegex: PatKind = ParseRegex => {
  <>.map(PatRegex)
    .map_err(|err| errors.push(err.into()))
    .unwrap_or(PatErr)
};

PatVal:    PatKind = LitKind               => PatVal(<>);
//PatVar:    PatKind = Symbol                => PatVar(<>);
PatTuple:  PatKind = "(" <Vec<Clause>> ")" => PatTuple(<>);
PatStruct: PatKind = "{" <Vec<Clause>> "}" => PatStruct(<>);
PatIgnore: PatKind = "_"                   => PatIgnore;

//=============================================================================
// Types
//=============================================================================

Type:      TypeVar = Spanned<TypeKind> => typer.intern(Type::from(<>));
TypeAnnot: TypeVar = (":" <Type>)?     => <>.unwrap_or_else(|| typer.fresh());
TypeElem:  TypeVar = (<Type> ";")?     => <>.unwrap_or_else(|| typer.fresh());

TypeKind: TypeKind = {
  Scalar,
  Optional,
  Struct,
  Array,
  Enum,
  ! => { errors.push(<>.into()); TypeErr },
};

Struct:   TypeKind = "{" <Fields<Type>> "}"     => Struct(<>);
Optional: TypeKind = <Type> "?"                 => Optional(<>);
Scalar:   TypeKind = ScalarKind                 => Scalar(<>);
Array:    TypeKind = "[" <TypeElem> <Shape> "]" => Array(<>);
Enum:     TypeKind = "<{" <Variants<Type>> "}>" => Enum(<>);

ScalarKind: ScalarKind = {
  "i8"   => I8,
  "i16"  => I16,
  "i32"  => I32,
  "i64"  => I64,
  "f32"  => F32,
  "f64"  => F64,
  "bool" => Bool,
  "null" => Null,
  "str"  => Str,
};

//=============================================================================
// Shape and Dimensions
//=============================================================================

Shape: Shape = Spanned<Vec<Dim<DimKind0>>> => Shape::from(<>);

Dim<DimKind>: Dim = Spanned<DimKind> => Dim::from(<>);

DimKind0: DimKind = {
  Box<Dim<DimKind0>> DimOp0 Box<Dim<DimKind1>> => DimOp(<>),
  DimKind1,
};

DimKind1: DimKind = {
  Box<Dim<DimKind1>> DimOp1 Box<Dim<DimKind2>> => DimOp(<>),
  DimKind2,
};

DimKind2: DimKind = {
  ParseI32 => <>.map(DimVal).unwrap_or(DimErr),
  "?"      => DimVar(0),
};

DimOp0: DimOpKind = {
  "+" => DimAdd,
  "-" => DimSub,
};

DimOp1: DimOpKind = {
  "*" => DimMul,
  "/" => DimDiv,
};
