use {
  crate::{ast::*, parser::*},
  lalrpop_util::ErrorRecovery,
  chrono::Duration,
  ExprKind::*,
  BinOpKind::*,
  UnOpKind::*,
  DeclKind::*,
  DimKind::*,
  DimOpKind::*,
  ScalarKind::*,
  TypeKind::*,
  PatternKind::*,
  LitKind::*,
  BIFKind::*,
};

//=============================================================================
// Grammar
//=============================================================================

grammar<'a>(
  errors: &'a mut Vec<ErrorRecovery<usize, Token<'input>, CompilerError>>,
  stack: &'a mut SymbolStack,
  table: &'a mut SymbolTable,
  typer: &'a mut Typer,
);

extern {
  type Error = CompilerError;
  type Location = usize;
}

//=============================================================================
// Tokens
//=============================================================================

match {
//=============================================================================
// Separators
//=============================================================================
  "(",
  ")",
  "{",
  "}",
  "[",
  "]",
  ",",
  ";",
//=============================================================================
// Operators
//=============================================================================
  "+",
  "-",
  "*",
  "/",
  "!",
  ":",
  "?",
  "=",
  "==",
  "!=",
  ">",
  "<",
  ">=",
  "<=",
  "=>",
  "|",
//=============================================================================
// Keywords
//=============================================================================
  "_",
  "if",
  "then",
  "else",
  "in",
  "fold",
  "fmap",
  "imap",
  "fun",
  "task",
  "end",
  "as",
  "match",
  "type",
//=============================================================================
// Types
//=============================================================================
  "i8",
  "i16",
  "i32",
  "i64",
  "f32",
  "f64",
  "bool",
  "str",
  "null",
  "json",
  "csv",
  "dataset",
} else {
//=============================================================================
// Decimal
//=============================================================================
  r"[0-9]+i8"                                                   => TI8Base10,
  r"[0-9]+i16"                                                  => TI16Base10,
  r"[0-9]+i64"                                                  => TI64Base10,
  r"(([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+))f32"  => TF32Base10,
//=============================================================================
// Binary
//=============================================================================
  r"0b[0-1]+i8"                                                 => TI8Base2,
  r"0b[0-1]+i16"                                                => TI16Base2,
  r"0b[0-1]+i64"                                                => TI64Base2,
//=============================================================================
// Hexadecimal
//=============================================================================
  r"0x[0-9a-fA-F]+i8"                                           => TI8Base16,
  r"0x[0-9a-fA-F]+i16"                                          => TI16Base16,
  r"0x[0-9a-fA-F]+i64"                                          => TI64Base16,
//=============================================================================
// Bool, String
//=============================================================================
  r"true|false"                                                 => TBool,
  r#""[^"]*""#                                                  => TStr,
//=============================================================================
// Regex
//=============================================================================
  r#"r"[^"]*""#                                                 => TRegex,
//=============================================================================
// Syntactic sugar for expressing different units of time
//=============================================================================
  r"[0-9]+s"                                                    => TSec,
  r"[0-9]+us"                                                   => TMSec,
  r"[0-9]+ms"                                                   => TUSec,
  r"[0-9]+ns"                                                   => TNSec,
  r"[0-9]+min"                                                  => TMin,
  r"[0-9]+h"                                                    => THour,
} else {
//=============================================================================
// Non-Postfixed
//=============================================================================
  r"[0-9]+"                                                     => TI32Base10,
  r"0b[0-1]+"                                                   => TI32Base2,
  r"0x[0-9a-fA-F]+"                                             => TI32Base16,
  r"([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+)"       => TF64Base10,
//=============================================================================
// Symbols
//=============================================================================
  r"[A-Za-z_][A-Za-z0-9_]*\("                                   => TFunSymbol,
  r"\.[A-Za-z_][A-Za-z0-9_]*\("                                 => TMethodSymbol,
  r"\p{Math}"                                                   => TUnicodeOp,
} else {
  r"\.[A-Za-z_][A-Za-z0-9_]*"                                   => TFieldSymbol,
  r"\.[0-9]+"                                                   => TIndex,
  r"[A-Za-z_][A-Za-z0-9_]*'*"                                   => TSymbol,
  r"[\p{Greek}\p{Emoji}][0-9]*'*"                               => TUnicodeSymbol,
} else {
//=============================================================================
// Skip
//=============================================================================
  r"\s*"                                                        => { },
  r"#[^\n\r]*[\n\r]*"                                           => { },
} else {
//=============================================================================
// Drop
//=============================================================================
  r"."                                                          => Undefined,
}

//=============================================================================
// Groups
//=============================================================================

Sep<T, S>:         Vec<T> = <v:(<T> S)*> <e:T?> => v.into_iter().chain(e).collect();
SepNonEmpty<T, S>: Vec<T> = <e:T> <v:(S <T>)*> => vec![e].into_iter().chain(v).collect();
SepMulti<T, S>:    Vec<T> = <e:T> <v:(S <T>)+> => vec![e].into_iter().chain(v).collect();
SepTrailing<T, S>: Vec<T> = (<T> S)*;
Vec<T>:            Vec<T> = Sep<T, ",">;
VecNonEmpty<T>:    Vec<T> = SepNonEmpty<T, ",">;
VecMulti<T>:       Vec<T> = SepMulti<T, ",">;
Semi<T>:           Vec<T> = Sep<T, ";">;
Single<T>:         Vec<T> = T => vec![<>];
Box<T>:            Box<T> = T => Box::new(<>);
Spanned<T>:        Spanned<T> = @L T @R => Spanned(<>);
Paren<T>:          T = "(" <T> ")";

//-----------------------------------------------------------------------------
// Operators
//-----------------------------------------------------------------------------

BinaryInfixNonAssociative<Op, Next>: ExprKind = {
  Box<Expr<Next>> Op Box<Expr<Next>> => BinOp(<>),
  Next,
};

BinaryInfixLeftAssociative<Op, Next>: ExprKind = {
  Box<Expr<BinaryInfixLeftAssociative<Op, Next>>> Op Box<Expr<Next>> => BinOp(<>),
  Next,
};

BinaryInfixRightAssociative<Op, Next>: ExprKind = {
  Box<Expr<Next>> Op Box<Expr<BinaryInfixLeftAssociative<Op, Next>>> => BinOp(<>),
  Next,
};

UnaryPostfix<Op, Next>: ExprKind = {
  <e:Box<Expr<UnaryPostfix<Op, Next>>>> <op:Op> => UnOp(op, e),
  Next,
};

UnaryPrefix<Op, Next>: ExprKind = {
  <op:Op> <e:Box<Expr<UnaryPrefix<Op, Next>>>> => UnOp(op, e),
  Next,
};

//=============================================================================
// Symbols
//=============================================================================

VarSymbol: SymbolKey = { 
  TSymbol        => table.intern(<>),
  TUnicodeSymbol => table.intern(<>),
};
FieldSymbol:  SymbolKey = TFieldSymbol  => table.intern(&<>[1..]);
FunSymbol:    SymbolKey = TFunSymbol    => table.intern(&<>[..<>.len()-1]);
MethodSymbol: SymbolKey = TMethodSymbol => table.intern(&<>[1..<>.len()-1]);
TaskSymbol:   SymbolKey = FunSymbol;

//=============================================================================
// Literals
//=============================================================================

ParseStr: String = TStr => <>[1..<>.len()].to_string();
ParseRegex: CompilerResult<regex::Regex> = Spanned<TRegex> => parse_regex(<>);
ParseBool: CompilerResult<bool> = Spanned<TBool> => parse_lit(<>);

//=============================================================================
// Numerals:
// * parse_lit_radix(<token>, <radix>, <prefix-len>, <suffix-len>)
//=============================================================================

ParseIndex: CompilerResult<usize> = {
  Spanned<TIndex>     => parse_lit_radix(<>, 10, 1, 0),
};

ParseF32: CompilerResult<f32> = {
  Spanned<TF32Base10> => parse_lit_radix(<>, 10, 0, 3),
};

ParseF64: CompilerResult<f64> = {
  Spanned<TF64Base10> => parse_lit_radix(<>, 10, 0, 0),
};

ParseI8: CompilerResult<i8> = {
  Spanned<TI8Base10>  => parse_lit_radix(<>, 10, 0, 2),
  Spanned<TI8Base2>   => parse_lit_radix(<>,  2, 2, 2),
  Spanned<TI8Base16>  => parse_lit_radix(<>, 16, 2, 2),
};

ParseI16: CompilerResult<i16> = {
  Spanned<TI16Base10> => parse_lit_radix(<>, 10, 0, 3),
  Spanned<TI16Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI16Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseI32: CompilerResult<i32> = {
  Spanned<TI32Base10> => parse_lit_radix(<>, 10, 0, 0),
  Spanned<TI32Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI32Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseI64: CompilerResult<i64> = {
  Spanned<TI64Base10> => parse_lit_radix(<>, 10, 0, 3),
  Spanned<TI64Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI64Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseTime: CompilerResult<Duration> = {
  Spanned<TSec>       => parse_lit_radix(<>, 10, 0, 3).map(Duration::seconds),
  Spanned<TUSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::microseconds),
  Spanned<TMSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::milliseconds),
  Spanned<TNSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::nanoseconds),
  Spanned<TMin>       => parse_lit_radix(<>, 10, 0, 3).map(Duration::minutes),
  Spanned<THour>      => parse_lit_radix(<>, 10, 0, 1).map(Duration::hours),
};

//=============================================================================
// Non-Terminals
//=============================================================================

pub Script = TaskDef* TypeDef* FunDef* Body;

//=============================================================================
// Name Resolving
//=============================================================================

Params: Vec<Ident> = Vec<Param> => {
  stack.push_scope();
  <>
    .into_iter()
    .map(|(sym, tv)| {
        let id = table.insert(Decl::new(sym, tv, VarDecl));
        stack.bind_local(sym, id);
        id
    })
    .collect::<Vec<_>>()
};

Param = <VarSymbol> ":" <Type>;

FunDecl: (Ident, Vec<Ident>) = "fun" <FunSymbol> <Params> ")" => {
  let (sym, param_ids) = (<>);
  let tv = typer.fresh();
  let id = table.insert(Decl::new(sym, tv, FunDecl));
  if let Err(err) = stack.bind_global(sym, id) {
      errors.push(err.into());
  }
  (id, param_ids)
};

FunDef: FunDef = <FunDecl> <Body> => {
  let ((id, param_ids), body) = (<>);
  stack.pop_scope();
  FunDef::new(id, param_ids, body)
};

TaskDef: TaskDef = <TaskDecl> <FunDef*> "end" => {
  let ((id, param_ids), fun_defs) = (<>);
  stack.pop_scope();
  TaskDef::new(id, param_ids, fun_defs)
};

TaskDecl: (Ident, Vec<Ident>) = "task" <TaskSymbol> <Params> ")" => {
  let (sym, param_ids) = (<>);
  let tv = typer.fresh();
  let id = table.insert(Decl::new(sym, tv, TaskDecl(Vec::new())));
  stack.push_scope();
  (id, param_ids)
};

LetDecl: (Ident, Box<Expr>) = <VarSymbol> <TypeAnnot> "=" <Box<Arg>> => {
  let (sym, tv, arg) = (<>);
  stack.push_scope();
  let id = table.insert(Decl::new(sym, tv, VarDecl));
  stack.bind_local(sym, id);
  (id, arg)
};

LetDef: ExprKind = <LetDecl> <Box<Body>> => {
  let ((id, arg), body) = (<>);
  stack.pop_scope();
  Let(id, arg, body) 
};

Var: ExprKind = <VarSymbol> => {
  stack.lookup(<>)
       .map(Var)
       .unwrap_or(ExprErr)
};

FunCall: ExprKind = <FunSymbol> <Vec<Arg>> ")" => {
  let (sym, args) = (<>);
  stack.lookup(sym)
       .map(|id| FunCall(id, args))
       .unwrap_or(ExprErr)
};

MethodCall: UnOpKind = <MethodSymbol> <Vec<Arg>> ")" => {
  let (sym, args) = (<>);
  stack.lookup(sym)
       .map(|id| MethodCall(id, args))
       .unwrap_or(UnOpErr)
};

TypeDef: TypeDef = "type" <VarSymbol> "=" <Type> => {
  let (sym, tv) = (<>);
  let id = table.insert(Decl::new(sym, tv, TypeDecl));
  if let Err(err) = stack.bind_global(sym, id) {
      errors.push(err.into());
  }
  TypeDef::new(id, tv)
};

ClosureDecl: Vec<Ident> = "|" <Params> "|";

ClosureDef: ExprKind = <ClosureDecl> "{" <Box<Body>> "}" => {
  stack.pop_scope();
  Closure(<>)
};

//=============================================================================
// Expressions
//=============================================================================

Body = Expr<ExprKind0>;
Arg  = Expr<ExprKind1>;

Expr<ExprKind>: Expr = Spanned<ExprKind> => Expr::from(<>, typer);

Op0: BinOpKind = {
  "==" => Eq,
  "!=" => Neq,
};

Op1: BinOpKind = {
  ">"  => Gt,
  "<"  => Lt,
  ">=" => Geq,
  "<=" => Leq,
};

Op2: BinOpKind = {
  "+" => Add,
  "-" => Sub,
};

Op3: BinOpKind = {
  "*" => Mul,
  "/" => Div,
};

Op4: UnOpKind = {
  "!" => Not,
//  "-" => Neg, TODO: Resolve ambiguity with custom lexer (joint-tokens)
};

Op5: UnOpKind = {
  "as" <Type> => Cast(<>),
  MethodCall  => <>,
  FieldSymbol => Access(<>),
  TupleIndex  => <>,
};

TupleIndex: UnOpKind = ParseIndex => {
  <>.map(Index)
    .map(Project)
    .unwrap_or_else(|err| { errors.push(err.into()); UnOpErr })
};

ExprKind0: ExprKind = {
  LetDef     => <>,
  ExprKind1  => <>,
};

ExprKind1: ExprKind = {
  "if" <Box<Body>> "then" <Box<Body>> "else" <Box<Body>>  => If(<>),
  "match" <Box<Body>> "{" <Vec<Clause>> "}"               => Match(<>),
  ExprKind2
};

ExprKind2: ExprKind = BinaryInfixLeftAssociative<Op0, ExprKind3>;
ExprKind3: ExprKind = BinaryInfixLeftAssociative<Op1, ExprKind4>;
ExprKind4: ExprKind = BinaryInfixLeftAssociative<Op2, ExprKind5>;
ExprKind5: ExprKind = BinaryInfixLeftAssociative<Op3, ExprKind6>;
ExprKind6: ExprKind =                UnaryPrefix<Op4, ExprKind7>;
ExprKind7: ExprKind =               UnaryPostfix<Op5, ExprKind8>;

ExprKind8: ExprKind = {
  Paren<ExprKind0>,
  FunCall,
  Lit,
  Var,
  ClosureDef,
  ConsArray,
  ConsStruct,
  ConsTuple,
  ! => { errors.push(<>.into()); ExprErr },
};

ConsArray: ExprKind = "[" <VecNonEmpty<Arg>> "]" => ConsArray(<>);

ConsStruct: ExprKind = "{" <VecNonEmpty<(<FieldSymbol> ":" <Arg>)>> "}" => ConsStruct(<>);

ConsTuple: ExprKind = "(" <VecMulti<Arg>> ")" => ConsTuple(<>);

Lit: ExprKind = LitKind => Lit(<>);

LitKind: LitKind = ParseLit => {
  <>.unwrap_or_else(|err| { errors.push(err.into()); LitErr })
};

ParseLit: CompilerResult<LitKind> = {
  ParseI8   => <>.map(LitI8),
  ParseI16  => <>.map(LitI16),
  ParseI32  => <>.map(LitI32),
  ParseI64  => <>.map(LitI64),
  ParseF32  => <>.map(LitF32),
  ParseF64  => <>.map(LitF64),
  ParseBool => <>.map(LitBool),
  ParseTime => <>.map(LitTime),
};

BIF: BIFKind = {
  "dataset" <Paren<Box<Arg>>>                 => Dataset(<>),
  "fold" <Paren<(<Box<Arg>> "," <Box<Arg>>)>> => Fold(<>.0, <>.1),
  "fmap" <Paren<Box<Arg>>>                    => Fmap(<>),
  "imap" <TypeAnnot> <Paren<Box<Arg>>>        => Imap(<>),
};

//=============================================================================
// Patterns
//=============================================================================

Clause = <RootPattern> "=>" <Body>;

RootPattern = Pattern<PatternKind0>;

Pattern<PatternKind>: Pattern = Spanned<PatternKind> => Pattern::from(<>);

PatternKind0: PatternKind = {
  <Box<Pattern<PatternKind0>>> "|" <Box<Pattern<PatternKind1>>> => Or(<>),
  PatternKind1
};

Regex: PatternKind = ParseRegex => {
  <>.map(Regex)
    .unwrap_or_else(|err| { errors.push(err.into()); PatternErr })
};

PatternKind1: PatternKind = {
  Regex                      => <>,
  LitKind                    => Val(<>),
//  VarSymbol                     => Var(<>),
  "(" <Vec<RootPattern>> ")" => DeconsTuple(<>),
  "_"                        => Wildcard,
};

//=============================================================================
// Types
//=============================================================================

Type:      TypeVar = Spanned<TypeKind> => typer.intern(Type::from(<>));
TypeAnnot: TypeVar = (":" <Type>)?     => <>.unwrap_or_else(|| typer.fresh());
TypeElem:  TypeVar = (<Type> ";")?     => <>.unwrap_or_else(|| typer.fresh());

TypeKind: TypeKind = {
  ScalarKind                      => Scalar(<>),
  <Type> "?"                      => Optional(<>),
  "{" <Vec<Param>> "}"            => Struct(<>),
  "[" <TypeElem> <Shape> "]"      => Array(<>),
  ! => { errors.push(<>.into()); TypeErr },
};

ScalarKind: ScalarKind = {
  "i8"   => I8,
  "i16"  => I16,
  "i32"  => I32,
  "i64"  => I64,
  "f32"  => F32,
  "f64"  => F64,
  "bool" => Bool,
  "null" => Null,
  "str"  => Str,
};

//=============================================================================
// Shape and Dimensions
//=============================================================================

Shape: Shape = Spanned<Vec<Dim<DimKind0>>> => Shape::from(<>);

Dim<DimKind>: Dim = Spanned<DimKind> => Dim::from(<>);

DimKind0: DimKind = {
  Box<Dim<DimKind0>> DimOp0 Box<Dim<DimKind1>> => DimOp(<>),
  DimKind1,
};

DimKind1: DimKind = {
  Box<Dim<DimKind1>> DimOp1 Box<Dim<DimKind2>> => DimOp(<>),
  DimKind2,
};

DimKind2: DimKind = {
  ParseI32 => <>.map(DimVal).unwrap_or(DimErr),
  "?"      => DimVar(0),
};

DimOp0: DimOpKind = {
  "+" => DimAdd,
  "-" => DimSub,
};

DimOp1: DimOpKind = {
  "*" => DimMul,
  "/" => DimDiv,
};
