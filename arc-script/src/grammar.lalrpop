use {
  crate::{ast::*, parser::*},
  lalrpop_util::ErrorRecovery,
  chrono::Duration,
  ExprKind::*,
  BinOpKind::*,
  UnOpKind::*,
  DeclKind::*,
  DimKind::*,
  ShapeKind::*,
  ScalarKind::*,
  TypeKind::*,
  PatternKind::*,
  LitKind::*,
  BIFKind::*,
};

//=============================================================================
// Grammar
//=============================================================================

grammar<'a>(
  errors: &'a mut Vec<ErrorRecovery<usize, Token<'input>, CompilerError>>,
  stack: &'a mut SymbolStack<'input>,
  table: &'a mut SymbolTable,
);

extern {
  type Error = CompilerError;
  type Location = usize;
}

//=============================================================================
// Tokens
//=============================================================================

match {
//=============================================================================
// Separators
//=============================================================================
  "(",
  ")",
  "{",
  "}",
  "[",
  "]",
  ",",
  ";",
//=============================================================================
// Operators
//=============================================================================
  "+",
  "-",
  "*",
  "/",
  "!",
  ":",
  "?",
  "=",
  "==",
  "=>",
  "|",
//=============================================================================
// Keywords
//=============================================================================
  "_",
  "if",
  "then",
  "else",
  "in",
  "fold",
  "fmap",
  "imap",
  "fun",
  "end",
  "as",
  "match",
  "type",
//=============================================================================
// Types
//=============================================================================
  "i8",
  "i16",
  "i32",
  "i64",
  "f32",
  "f64",
  "bool",
  "str",
  "null",
  "json",
  "csv",
  "dataset",
} else {
//=============================================================================
// Decimal
//=============================================================================
  r"[-]?[0-9]+i8"                                                  => TI8Base10,
  r"[-]?[0-9]+i16"                                                 => TI16Base10,
  r"[-]?[0-9]+i64"                                                 => TI64Base10,
  r"[-]?(([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+))f32" => TF32Base10,
//=============================================================================
// Binary
//=============================================================================
  r"0b[0-1]+i8"                                                 => TI8Base2,
  r"0b[0-1]+i16"                                                => TI16Base2,
  r"0b[0-1]+i64"                                                => TI64Base2,
//=============================================================================
// Hexadecimal
//=============================================================================
  r"0x[0-9a-fA-F]+i8"                                           => TI8Base16,
  r"0x[0-9a-fA-F]+i16"                                          => TI16Base16,
  r"0x[0-9a-fA-F]+i64"                                          => TI64Base16,
//=============================================================================
// Bool, String
//=============================================================================
  r"true|false"                                                 => TBool,
  r#""[^"]*""#                                                  => TStr,
//=============================================================================
// Regex
//=============================================================================
  r#"r"[^"]*""#                                                 => TRegex,
//=============================================================================
// Syntactic sugar for expressing different units of time
//=============================================================================
  r"[0-9]+s"                                                       => TSec,
  r"[0-9]+us"                                                      => TMSec,
  r"[0-9]+ms"                                                      => TUSec,
  r"[0-9]+ns"                                                      => TNSec,
  r"[0-9]+min"                                                     => TMin,
  r"[0-9]+h"                                                       => THour,
} else {
//=============================================================================
// Non-Postfixed
//=============================================================================
  r"[-]?[0-9]+"                                                 => TI32Base10,
  r"0b[0-1]+"                                                   => TI32Base2,
  r"0x[0-9a-fA-F]+"                                             => TI32Base16,
  r"([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+)"       => TF64Base10,
//=============================================================================
// Symbols
//=============================================================================
  r"[A-Za-z_][A-Za-z0-9_]*\("                                   => TFunSymbol,
  r"\.[A-Za-z_][A-Za-z0-9_]*\("                                 => TMethodSymbol,
  r"\p{Math}"                                                   => TUnicodeOp,
} else {
  r"\.[A-Za-z_][A-Za-z0-9_]*"                                   => TFieldSymbol,
  r"\.[0-9]+"                                                   => TIndex,
  r"[A-Za-z_][A-Za-z0-9_]*'*"                                   => TSymbol,
  r"[\p{Greek}\p{Emoji}][0-9]*'*"                               => TUnicodeSymbol,
} else {
//=============================================================================
// Skip
//=============================================================================
  r"\s*"                                                        => { },
  r"#[^\n\r]*[\n\r]*"                                           => { },
} else {
//=============================================================================
// Drop
//=============================================================================
  r"."                                                          => Undefined,
}

//=============================================================================
// Groups
//=============================================================================

Sep<T, S>: Vec<T> = <v:(<T> S)*> <e:T?> => v.into_iter().chain(e).collect();
SepNonEmpty<T, S>: Vec<T> = <e:T> <v:(S <T>)*> => vec![e].into_iter().chain(v).collect();
SepMulti<T, S>: Vec<T> = <e:T> <v:(S <T>)+> => vec![e].into_iter().chain(v).collect();
SepTrailing<T, S> = (<T> S)*;
Vec<T> = Sep<T, ",">;
VecNonEmpty<T> = SepNonEmpty<T, ",">;
VecMulti<T> = SepMulti<T, ",">;
Semi<T> = Sep<T, ";">;
Single<T>: Vec<T> = T => vec![<>];
Box<T>: Box<T> = T => Box::new(<>);
Spanned<T>: Spanned<T> = @L T @R => Spanned(<>);
Paren<T>: T = "(" <T> ")";

//-----------------------------------------------------------------------------
// Operators
//-----------------------------------------------------------------------------

BinaryInfixNonAssociative<Op, Next>: ExprKind = {
  Box<Expr<Next>> Op Box<Expr<Next>> => BinOp(<>),
  Next,
};

BinaryInfixLeftAssociative<Op, Next>: ExprKind = {
  Box<Expr<BinaryInfixLeftAssociative<Op, Next>>> Op Box<Expr<Next>> => BinOp(<>),
  Next,
};

BinaryInfixRightAssociative<Op, Next>: ExprKind = {
  Box<Expr<Next>> Op Box<Expr<BinaryInfixLeftAssociative<Op, Next>>> => BinOp(<>),
  Next,
};

UnaryPostfix<Op, Next>: ExprKind = {
  <e:Box<Expr<UnaryPostfix<Op, Next>>>> <op:Op> => UnOp(op, e),
  Next,
};

UnaryPrefix<Op, Next>: ExprKind = {
  <op:Op> <e:Box<Expr<UnaryPrefix<Op, Next>>>> => UnOp(op, e),
  Next,
};

//=============================================================================
// Symbols
//=============================================================================

VarSymbol:    Symbol<'input> = { TSymbol, TUnicodeSymbol };
FieldSymbol:  Symbol<'input> = TFieldSymbol  => &<>[1..];
FunSymbol:    Symbol<'input> = TFunSymbol    => &<>[..<>.len()-1];
MethodSymbol: Symbol<'input> = TMethodSymbol => &<>[1..<>.len()-1];

//=============================================================================
// Literals
//=============================================================================

ParseStr: String = TStr => <>[1..<>.len()].to_string();
ParseRegex: CompilerResult<regex::Regex> = Spanned<TRegex> => parse_regex(<>);
ParseBool: CompilerResult<bool> = Spanned<TBool> => parse_lit(<>);

//=============================================================================
// Numerals:
// * parse_lit_radix(<token>, <radix>, <prefix-len>, <suffix-len>)
//=============================================================================

ParseIndex: CompilerResult<usize> = {
  Spanned<TIndex>     => parse_lit_radix(<>, 10, 1, 0),
};

ParseF32: CompilerResult<f32> = {
  Spanned<TF32Base10> => parse_lit_radix(<>, 10, 0, 3),
};

ParseF64: CompilerResult<f64> = {
  Spanned<TF64Base10> => parse_lit_radix(<>, 10, 0, 0),
};

ParseI8: CompilerResult<i8> = {
  Spanned<TI8Base10>  => parse_lit_radix(<>, 10, 0, 2),
  Spanned<TI8Base2>   => parse_lit_radix(<>,  2, 2, 2),
  Spanned<TI8Base16>  => parse_lit_radix(<>, 16, 2, 2),
};

ParseI16: CompilerResult<i16> = {
  Spanned<TI16Base10> => parse_lit_radix(<>, 10, 0, 3),
  Spanned<TI16Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI16Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseI32: CompilerResult<i32> = {
  Spanned<TI32Base10> => parse_lit_radix(<>, 10, 0, 0),
  Spanned<TI32Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI32Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseI64: CompilerResult<i64> = {
  Spanned<TI64Base10> => parse_lit_radix(<>, 10, 0, 3),
  Spanned<TI64Base2>  => parse_lit_radix(<>,  2, 2, 3),
  Spanned<TI64Base16> => parse_lit_radix(<>, 16, 2, 3),
};

ParseTime: CompilerResult<Duration> = {
  Spanned<TSec>       => parse_lit_radix(<>, 10, 0, 3).map(Duration::seconds),
  Spanned<TUSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::microseconds),
  Spanned<TMSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::milliseconds),
  Spanned<TNSec>      => parse_lit_radix(<>, 10, 0, 3).map(Duration::nanoseconds),
  Spanned<TMin>       => parse_lit_radix(<>, 10, 0, 3).map(Duration::minutes),
  Spanned<THour>      => parse_lit_radix(<>, 10, 0, 1).map(Duration::hours),
};

//=============================================================================
// Non-Terminals
//=============================================================================

pub Script = TypeDef* FunDef* Body;

//=============================================================================
// Name Resolving
//=============================================================================

Params: Vec<Ident> = Vec<Param> => {
  <>
    .into_iter()
    .map(|(sym, ty)| {
        let id = table.insert(Decl::new(sym, ty, VarDecl));
        stack.bind_local(sym, id);
        id
    })
    .collect::<Vec<_>>()
};

Param = <VarSymbol> <OptionalType>;

FunDecl: (Ident, Vec<Ident>) = "fun" <FunSymbol> <Params> ")" => {
  let (fun_sym, param_ids) = (<>);
  let fun_id = table.insert(Decl::new(fun_sym, Type::fun(param_ids.len()), FunDecl));
  if let Err(err) = stack.bind_global(fun_sym, fun_id) {
      errors.push(err.into());
  }
  stack.push_scope();
  (fun_id, param_ids)
};

FunDef: FunDef = <FunDecl> <Body> => {
  let ((fun_id, param_ids), body) = (<>);
  stack.pop_scope();
  FunDef::new(fun_id, param_ids, body)
};

LetDecl: (Ident, Box<Expr>) = <VarSymbol> <OptionalType> "=" <Box<Arg>> => {
  let (sym, ty, arg) = (<>);
  stack.push_scope();
  let id = table.insert(Decl::new(sym, ty, VarDecl));
  stack.bind_local(sym, id);
  (id, arg)
};

LetDef: ExprKind = <LetDecl> <Box<Body>> => {
  let ((id, arg), body) = (<>);
  stack.pop_scope();
  Let(id, arg, body) 
};

Var: ExprKind = <VarSymbol> => {
  stack.lookup(<>)
       .map(Var)
       .unwrap_or(ExprErr)
};

FunCall: ExprKind = <FunSymbol> <Vec<Arg>> ")" => {
  let (sym, args) = (<>);
  stack.lookup(sym)
       .map(|id| FunCall(id, args))
       .unwrap_or(ExprErr)
};

MethodCall: UnOpKind = <MethodSymbol> <Vec<Arg>> ")" => {
  let (sym, args) = (<>);
  stack.lookup(sym)
       .map(|id| MethodCall(id, args))
       .unwrap_or(UnOpErr)
};

TypeDef: TypeDef = "type" <VarSymbol> "=" <Type> => {
  let (sym, ty) = (<>);
  let id = table.insert(Decl::new(sym, ty.clone(), TypeDecl));
  if let Err(err) = stack.bind_global(sym, id) {
      errors.push(err.into());
  }
  TypeDef::new(id, ty)
};

ClosureDecl: Vec<Ident> = "|" <Params> "|";

ClosureDef: ExprKind = <ClosureDecl> "{" <Box<Body>> "}" => Closure(<>);

//=============================================================================
// Expressions
//=============================================================================

Body = Expr<ExprKind0>;
Arg  = Expr<ExprKind1>;

Expr<ExprKind>: Expr = Spanned<ExprKind> => Expr::from(<>);

Op0: BinOpKind = {
  "==" => Eq,
};

Op1: BinOpKind = {
  "+" => Add,
  "-" => Sub,
};

Op2: BinOpKind = {
  "*" => Mul,
  "/" => Div,
};

Op3: UnOpKind = {
  "!" => Not,
//  "-" => Neg, TODO: Resolve ambiguity with custom lexer (joint-tokens)
};

Op4: UnOpKind = {
  "as" <Type> => Cast(<>),
  MethodCall  => <>,
  FieldSymbol => Access(<>.into()),
  TupleIndex  => <>,
};

TupleIndex: UnOpKind = ParseIndex => {
  <>.map(Index)
    .map(Project)
    .unwrap_or_else(|err| { errors.push(err.into()); UnOpErr })
};

OptionalType: Type = (":" <Type>)? => <>.unwrap_or(Type::new());

ExprKind0: ExprKind = {
  LetDef     => <>,
  ExprKind1  => <>,
};

ExprKind1: ExprKind = {
  "if" <Box<Body>> "then" <Box<Body>> "else" <Box<Body>>  => If(<>),
  "match" <Box<Body>> "{" <Vec<Clause>> "}"               => Match(<>),
  ExprKind2
};

ExprKind2: ExprKind = BinaryInfixLeftAssociative<Op0, ExprKind3>;
ExprKind3: ExprKind = BinaryInfixLeftAssociative<Op1, ExprKind4>;
ExprKind4: ExprKind = BinaryInfixLeftAssociative<Op2, ExprKind5>;
ExprKind5: ExprKind =                UnaryPrefix<Op3, ExprKind6>;
ExprKind6: ExprKind =               UnaryPostfix<Op4, ExprKind7>;

ExprKind7: ExprKind = {
  Paren<ExprKind0>                           => <>,
  FunCall                                    => <>,
  Lit                                        => <>,
  Var                                        => <>,
  ClosureDef                                 => <>,
  "[" <VecNonEmpty<Arg>> "]"                 => ConsArray(<>),
//  "{" <VecNonEmpty<(<Symbol> ":" <Arg>)>> "}" => ConsStruct(<>),
  "(" <VecMulti<Arg>> ")"                    => ConsTuple(<>),
  ! => { errors.push(<>.into()); ExprErr },
};

Lit: ExprKind = LitKind => Lit(<>);

LitKind: LitKind = ParseLit => {
  <>.unwrap_or_else(|err| { errors.push(err.into()); LitErr })
};

ParseLit: CompilerResult<LitKind> = {
  ParseI32  => <>.map(LitI32),
  ParseI64  => <>.map(LitI64),
  ParseF32  => <>.map(LitF32),
  ParseF64  => <>.map(LitF64),
  ParseBool => <>.map(LitBool),
  ParseTime => <>.map(LitTime),
};

BIF: BIFKind = {
  "dataset" <Paren<Box<Arg>>>                 => Dataset(<>),
  "fold" <Paren<(<Box<Arg>> "," <Box<Arg>>)>> => Fold(<>.0, <>.1),
  "fmap" <Paren<Box<Arg>>>                    => Fmap(<>),
  "imap" <OptionalType> <Paren<Box<Arg>>>     => Imap(<>),
};

//=============================================================================
// Patterns
//=============================================================================

Clause = <RootPattern> "=>" <Body>;

RootPattern = Pattern<PatternKind0>;

Pattern<PatternKind>: Pattern = Spanned<PatternKind> => Pattern::from(<>);

PatternKind0: PatternKind = {
  <Box<Pattern<PatternKind0>>> "|" <Box<Pattern<PatternKind1>>> => Or(<>),
  PatternKind1
};

Regex: PatternKind = ParseRegex => {
  <>.map(Regex)
    .unwrap_or_else(|err| { errors.push(err.into()); PatternErr })
};

PatternKind1: PatternKind = {
  Regex                      => <>,
  LitKind                    => Val(<>),
//  VarSymbol                     => Var(<>),
  "(" <Vec<RootPattern>> ")" => DeconsTuple(<>),
  "_"                        => Wildcard,
};

//=============================================================================
// Types
//=============================================================================

Type: Type = Spanned<TypeKind> => Type::from(<>);

TypeKind: TypeKind = {
  ScalarKind                      => Scalar(<>),
  <Box<Type>> "?"                 => Optional(<>),
//  "{" <Vec<Param>> "}"            => Struct(<>),
//  "[" <Box<ElemType>> <Shape> "]" => Array(<>),
  ! => { errors.push(<>.into()); TypeErr },
};

//ElemType: Type = (<Spanned<Scalar>> ";")? => <>.map(Type::from).unwrap_or(Type::new());

ScalarKind: ScalarKind = {
  "i8"   => I8,
  "i16"  => I16,
  "i32"  => I32,
  "i64"  => I64,
  "f32"  => F32,
  "f64"  => F64,
  "bool" => Bool,
  "null" => Null,
  "str"  => Str,
};

//=============================================================================
// Shape and Dimensions
//=============================================================================

Shape: Shape = Spanned<ShapeKind> => Shape::from(<>);

ShapeKind: ShapeKind = {
  <Vec<Dim>> => Ranked(<>),
  "*"        => Unranked,
};

Dim: Dim = Spanned<DimKind> => Dim::from(<>);

DimKind: DimKind = {
    Arg => Symbolic(<>),
    "?" => Hole,
};
