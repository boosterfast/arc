---
source: arc-script-test/compile/src/insta.rs
expression: s
input_file: arc-script-test/compile/src/tests/expect_mlir_fail_todo/task_id_untagged.arc

---
#[allow(non_snake_case)]
#[allow(unused_must_use)]
#[allow(dead_code)]
#[allow(unused_variables)]
#[allow(unused_imports)]
#[allow(unused_braces)]
pub mod defs {
    use super::*;
    pub use arc_script::arcorn;
    pub use arc_script::arcorn::state::{ArcMapOps, ArcRefOps, ArcSetOps, ArcVecOps};
    pub use arcon::prelude::*;
    pub struct Identity<'i, 'source, 'timer, 'channel, B: Backend, C: ComponentDefinition> {
        pub data: &'i mut IdentityData,
        pub ctx: &'i mut OperatorContext<'source, 'timer, 'channel, IdentityData, B, C>,
        pub timestamp: Option<u64>,
        pub key: u64,
    }
    pub struct IdentityData {
        pub state: IdentityState,
    }
    #[derive(ArconState)]
    pub struct IdentityState {}
    impl StateConstructor for IdentityState {
        type BackendType = Sled;
        fn new(backend: Arc<Self::BackendType>) -> Self {
            Self {}
        }
    }
    impl IdentityData {
        fn new() -> OperatorBuilder<IdentityData> {
            OperatorBuilder {
                constructor: Arc::new(move |backend| IdentityData {
                    state: IdentityState {},
                }),
                conf: Default::default(),
            }
        }
    }
    impl Operator for IdentityData {
        type IN = Struct3vali323keyi32End;
        type OUT = Struct3vali323keyi32End;
        type TimerState = ArconNever;
        type OperatorState = IdentityState;
        fn handle_element(
            &mut self,
            element: ArconElement<Self::IN>,
            ref mut ctx: OperatorContext<Self, impl Backend, impl ComponentDefinition>,
        ) -> OperatorResult<()> {
            let ArconElement { timestamp, data } = element;
            let mut task = Identity {
                data: self,
                ctx,
                timestamp,
                key: data.get_key(),
            };
            task.handle_element(data);
            Ok(())
        }
        fn state(&mut self) -> &mut Self::OperatorState {
            &mut self.state
        }
        fn handle_timeout(
            &mut self,
            timeout: Self::TimerState,
            ref mut ctx: OperatorContext<Self, impl Backend, impl ComponentDefinition>,
        ) -> OperatorResult<()> {
            Ok(())
        }
        fn persist(&mut self) -> OperatorResult<()> {
            self.state.persist();
            Ok(())
        }
    }
    impl<'i, 'source, 'timer, 'channel, B: Backend, C: ComponentDefinition>
        Identity<'i, 'source, 'timer, 'channel, B, C>
    {
        fn handle_element(&mut self, event_0: Struct3vali323keyi32End) -> OperatorResult<()> {
            {
                self.emit(event_0)
            };
            Ok(())
        }
        fn emit(&mut self, data: Struct3vali323keyi32End) {
            let element = ArconElement {
                data,
                timestamp: self.timestamp,
            };
            self.ctx.output(element);
        }
    }
    pub fn main(input_0: Stream<Struct3vali323keyi32End>) -> Stream<Struct3vali323keyi32End> {
        let y_1_0 = IdentityData::new();
        let y_1_1 = Stream::operator(input_0, y_1_0);
        y_1_1
    }
    #[arcorn::rewrite]
    #[derive(Copy)]
    pub struct Struct3vali323keyi32End {
        val: i32,
        key: i32,
    }
}
pub use defs::*;


