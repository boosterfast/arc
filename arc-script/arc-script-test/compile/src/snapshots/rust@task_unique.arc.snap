---
source: arc-script-test/compile/src/insta.rs
expression: s
input_file: arc-script-test/compile/src/tests/expect_mlir_fail_todo/task_unique.arc

---
#[allow(non_snake_case)]
#[allow(unused_must_use)]
#[allow(dead_code)]
#[allow(unused_variables)]
#[allow(unused_imports)]
#[allow(unused_braces)]
pub mod defs {
    use super::*;
    pub use arc_script::arcorn;
    pub use arc_script::arcorn::state::{ArcMapOps, ArcRefOps, ArcSetOps, ArcVecOps};
    pub use arcon::prelude::*;
    pub struct UniqueSet<'i, 'source, 'timer, 'channel, B: Backend, C: ComponentDefinition> {
        pub data: &'i mut UniqueSetData,
        pub ctx: &'i mut OperatorContext<'source, 'timer, 'channel, UniqueSetData, B, C>,
        pub timestamp: Option<u64>,
    }
    pub struct UniqueSetData {
        pub state: UniqueSetState,
    }
    #[derive(ArconState)]
    pub struct UniqueSetState {
        pub set_0: arc_script::arcorn::state::ArcSet<i32, Sled>,
    }
    impl StateConstructor for UniqueSetState {
        type BackendType = Sled;
        fn new(backend: Arc<Self::BackendType>) -> Self {
            Self {
                set_0: <arc_script::arcorn::state::ArcSet<i32, Sled>>::arc_set_default(
                    "set_0",
                    backend.clone(),
                )
                .unwrap(),
            }
        }
    }
    impl UniqueSetData {
        fn new() -> OperatorBuilder<UniqueSetData> {
            OperatorBuilder {
                constructor: Arc::new(move |backend| UniqueSetData {
                    state: UniqueSetState {
                        set_0: <arc_script::arcorn::state::ArcSet<i32, Sled>>::arc_set_new(
                            "set_0",
                            backend.clone(),
                            {
                                let y_1_0 = <::std::collections::HashSet<i32>>::new();
                                y_1_0
                            },
                        )
                        .unwrap(),
                    },
                }),
                conf: Default::default(),
            }
        }
    }
    impl Operator for UniqueSetData {
        type IN = Struct5valuei32End;
        type OUT = Struct5valuei32End;
        type TimerState = ArconNever;
        type OperatorState = UniqueSetState;
        fn handle_element(
            &mut self,
            elem: ArconElement<Self::IN>,
            ref mut ctx: OperatorContext<Self, impl Backend, impl ComponentDefinition>,
        ) -> OperatorResult<()> {
            let ArconElement { timestamp, data } = elem;
            let event = data.value;
            let mut task = UniqueSet {
                data: self,
                ctx,
                timestamp,
            };
            task.handle(event);
            Ok(())
        }
        fn state(&mut self) -> &mut Self::OperatorState {
            &mut self.state
        }
        arcon::ignore_timeout!();
        arcon::ignore_persist!();
    }
    impl<'i, 'source, 'timer, 'channel, B: Backend, C: ComponentDefinition>
        UniqueSet<'i, 'source, 'timer, 'channel, B, C>
    {
        fn handle(&mut self, event_0: i32) -> OperatorResult<()> {
            {
                let y_1_0 = !self.data.state.set_0.arc_set_contains(event_0).unwrap();
                let y_1_1 = if y_1_0 {
                    let y_2_0 = self.data.state.set_0.arc_set_add({ event_0 }).unwrap();
                    let y_2_1 = y_2_0;
                    self.emit(event_0);
                    y_2_1
                } else {
                    let y_2_0 = ();
                    y_2_0
                };
                y_1_1
            };
            Ok(())
        }
        fn emit(&mut self, event_0: i32) {
            let data = Struct5valuei32End { value: event_0 };
            let elem = ArconElement {
                data,
                timestamp: self.timestamp,
            };
            self.ctx.output(elem);
        }
    }
    pub struct UniqueMap<'i, 'source, 'timer, 'channel, B: Backend, C: ComponentDefinition> {
        pub data: &'i mut UniqueMapData,
        pub ctx: &'i mut OperatorContext<'source, 'timer, 'channel, UniqueMapData, B, C>,
        pub timestamp: Option<u64>,
    }
    pub struct UniqueMapData {
        pub state: UniqueMapState,
    }
    #[derive(ArconState)]
    pub struct UniqueMapState {
        pub map_0: arc_script::arcorn::state::ArcMap<i32, bool, Sled>,
    }
    impl StateConstructor for UniqueMapState {
        type BackendType = Sled;
        fn new(backend: Arc<Self::BackendType>) -> Self {
            Self {
                map_0: <arc_script::arcorn::state::ArcMap<i32, bool, Sled>>::arc_map_default(
                    "map_0",
                    backend.clone(),
                )
                .unwrap(),
            }
        }
    }
    impl UniqueMapData {
        fn new() -> OperatorBuilder<UniqueMapData> {
            OperatorBuilder {
                constructor: Arc::new(move |backend| UniqueMapData {
                    state: UniqueMapState {
                        map_0: <arc_script::arcorn::state::ArcMap<i32, bool, Sled>>::arc_map_new(
                            "map_0",
                            backend.clone(),
                            {
                                let y_1_0 = <::std::collections::HashMap<i32, bool>>::new();
                                y_1_0
                            },
                        )
                        .unwrap(),
                    },
                }),
                conf: Default::default(),
            }
        }
    }
    impl Operator for UniqueMapData {
        type IN = Struct5valuei32End;
        type OUT = Struct5valuei32End;
        type TimerState = ArconNever;
        type OperatorState = UniqueMapState;
        fn handle_element(
            &mut self,
            elem: ArconElement<Self::IN>,
            ref mut ctx: OperatorContext<Self, impl Backend, impl ComponentDefinition>,
        ) -> OperatorResult<()> {
            let ArconElement { timestamp, data } = elem;
            let event = data.value;
            let mut task = UniqueMap {
                data: self,
                ctx,
                timestamp,
            };
            task.handle(event);
            Ok(())
        }
        fn state(&mut self) -> &mut Self::OperatorState {
            &mut self.state
        }
        arcon::ignore_timeout!();
        arcon::ignore_persist!();
    }
    impl<'i, 'source, 'timer, 'channel, B: Backend, C: ComponentDefinition>
        UniqueMap<'i, 'source, 'timer, 'channel, B, C>
    {
        fn handle(&mut self, event_1: i32) -> OperatorResult<()> {
            {
                let y_1_0 = !self.data.state.map_0.arc_map_contains(event_1).unwrap();
                let y_1_1 = if y_1_0 {
                    let y_2_0 = true;
                    let y_2_1 = self
                        .data
                        .state
                        .map_0
                        .arc_map_insert(event_1, y_2_0)
                        .unwrap();
                    self.emit(event_1);
                    y_2_1
                } else {
                    let y_2_0 = ();
                    y_2_0
                };
                y_1_1
            };
            Ok(())
        }
        fn emit(&mut self, event_1: i32) {
            let data = Struct5valuei32End { value: event_1 };
            let elem = ArconElement {
                data,
                timestamp: self.timestamp,
            };
            self.ctx.output(elem);
        }
    }
    #[arcorn::rewrite]
    #[derive(Copy)]
    pub struct Struct5valuei32End {
        value: i32,
    }
}
pub use defs::*;


