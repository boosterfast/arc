<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tasks and Channels - Arc-Lang</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Arc-Lang documentation.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="../tour/mod.html">Tour of Arc-Lang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tour/basics.html">Basics</a></li><li class="chapter-item expanded "><a href="../tour/tasks.html" class="active">Tasks and Channels</a></li><li class="chapter-item expanded "><a href="../tour/queries.html">Queries</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/mod.html">Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/word-count.html">Word Count</a></li><li class="chapter-item expanded "><a href="../examples/tf-idf.html">TF-IDF</a></li><li class="chapter-item expanded "><a href="../examples/sensor-data-aggregation.html">Sensor Data Aggregation</a></li></ol></li><li class="chapter-item expanded "><a href="../command-line-interface.html">Command Line Interface</a></li><li class="chapter-item expanded "><a href="../arc-lang/mod.html">Arc-Lang Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../arc-lang/Program.html">Programs</a></li><li class="chapter-item expanded "><a href="../arc-lang/Name.html">Names</a></li><li class="chapter-item expanded "><a href="../arc-lang/Path.html">Paths</a></li><li class="chapter-item expanded "><a href="../arc-lang/Value.html">Values</a></li><li class="chapter-item expanded "><a href="../arc-lang/Type.html">Types</a></li><li class="chapter-item expanded "><a href="../arc-lang/Block.html">Blocks</a></li><li class="chapter-item expanded "><a href="../arc-lang/Stmt.html">Statements</a></li><li class="chapter-item expanded "><a href="../arc-lang/Expr.html">Expressions</a></li><li class="chapter-item expanded "><a href="../arc-lang/Pattern.html">Patterns</a></li><li class="chapter-item expanded "><a href="../arc-lang/Item.html">Items</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../arc-lang/Global.html">Globals</a></li><li class="chapter-item expanded "><a href="../arc-lang/Def.html">Functions</a></li><li class="chapter-item expanded "><a href="../arc-lang/Task.html">Tasks</a></li><li class="chapter-item expanded "><a href="../arc-lang/TypeAlias.html">Type Aliases</a></li><li class="chapter-item expanded "><a href="../arc-lang/TypeClass.html">Type Classes</a></li><li class="chapter-item expanded "><a href="../arc-lang/Instance.html">Type Class Instances</a></li><li class="chapter-item expanded "><a href="../arc-lang/ExternDef.html">Extern Functions</a></li><li class="chapter-item expanded "><a href="../arc-lang/ExternType.html">Extern Types</a></li><li class="chapter-item expanded "><a href="../arc-lang/Use.html">Uses</a></li><li class="chapter-item expanded "><a href="../arc-lang/Enum.html">Enums</a></li><li class="chapter-item expanded "><a href="../arc-lang/Module.html">Modules</a></li></ol></li><li class="chapter-item expanded "><a href="../arc-lang/Params.html">Parameters</a></li><li class="chapter-item expanded "><a href="../arc-lang/Generics.html">Generics</a></li><li class="chapter-item expanded "><a href="../arc-lang/Assign.html">Assignments</a></li><li class="chapter-item expanded "><a href="../arc-lang/Annots.html">Annotations</a></li></ol></li><li class="chapter-item expanded "><a href="../dev/mod.html">Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/ci.html">Continuous Integration</a></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/mod.html">Arc-MLIR Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/arc-mlir/Program.html">Programs</a></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/Name.html">Names</a></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/Operation.html">Operations</a></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/Type.html">Types</a></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/Value.html">Values</a></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/Block.html">Blocks</a></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/Item.html">Items</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/arc-mlir/Func.html">Functions</a></li></ol></li><li class="chapter-item expanded "><a href="../dev/arc-mlir/Params.html">Parameters</a></li></ol></li><li class="chapter-item expanded "><a href="../dev/arc-runtime/mod.html">Arc-Runtime Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/arc-runtime/execution-model.html">Execution Model</a></li><li class="chapter-item expanded "><a href="../dev/arc-runtime/data-model.html">Data Model</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../history/mod.html">History</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../history/tasks.html">Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="../bibliography.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Arc-Lang</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tasks-and-channels"><a class="header" href="#tasks-and-channels">Tasks and Channels</a></h1>
<p>Datastreams have become a prominent data model for analysing live data. A <em>datastream</em> is conceptually an infinite sequence of events, where an <em>event</em> is a data point produced by the stream at a specific moment in time. Arc-Lang provides the concept of tasks and channels to support fine grained processing of datastreams. A <em>channel</em> is a buffer of events which supports two basic operations. Data can be <em>pushed</em> and <em>pulled</em> into and out of the channel's buffer by tasks. In this context, a <em>task</em> is a lightweight thread that is executing an asynchronous function (i.e., a function that can suspend its execution). Tasks can thus await events to arrive on ingoing channels, do some processing, and emit new events onto outgoing channels.</p>
<pre><code><b>task</b> map(i, f): (o) {
    <b>loop</b> {
        o ! f(<b>receive</b> i);
    }
}

<b>def</b> main() {
    <b>val</b> stream0 = source(<b style="color:darkorange">0</b>..);
    <b>val</b> stream1 = map(stream0, <b>fun</b>(x) = x + <b style="color:darkorange">1</b>);
}</code></pre>
<p>In the above code, <code>map</code> is a task which takes a stream on an input channel <code>i</code>, a function <code>f</code>, and produces a stream on an output channel <code>o</code>. The execution of the task enters an infinite loop which receives events from <code>i</code> using the <code>receive</code> operator, applies function <code>f</code>, and emits the result to <code>o</code> using the <code>!</code> operator. The <code>main</code> function instantiates the task using function application syntax.</p>
<h2 id="directions"><a class="header" href="#directions">Directions</a></h2>
<p>All channels have a <em>direction</em>. Data can either be pushed into a channel or pulled out of it, but not both. Tasks which push data are referred to as &quot;<em>producers</em>&quot; and tasks which pull data are referred to as &quot;<em>consumers</em>&quot;. It is possible for a task to simultaneously be both a producer and a consumer, but not for the same channel. We refer to pull-only channels as streams (<code>Stream[T]</code>) and push-only channels as drains (<code>Drain[T]</code>). To make the idea more clear, consider this fully type annotated example:</p>
<pre><code><b>task</b> map(i: Stream[i32], f: <b>fun</b>(i32):i32): (o: Drain[i32]) {
    <b>loop</b> {
        o ! f(<b>receive</b> i);
    }
}

<b>def</b> main() {
    <b>val</b> stream0: Stream[i32] = source(<b style="color:darkorange">0</b>..);
    <b>val</b> stream1: Stream[i32] = map(stream0, <b>fun</b>(x) = x + <b style="color:darkorange">1</b>);
}</code></pre>
<h2 id="deadlock-avoidance"><a class="header" href="#deadlock-avoidance">Deadlock Avoidance</a></h2>
<p>The purpose of introducing tasks and directions is to avoid deadlocks that may occur from cyclic channel-dependencies. To give an example, channels in the Go language have directions like Arc-Lang but no task-abstraction. Go instead exposes the more general concept of goroutines which are lightweight threads that can suspend execution anywhere. For example, it is possible in Go to write the following:</p>
<pre><code class="language-go">package main

func map(i &lt;-chan int, f func(int) int, o chan&lt;- int) {
    for x := range i {
        o &lt;- f(x);
    }
}

func main() {
    c := make(chan int);
    go map(c, c);
}
</code></pre>
<p>The above code has a problem. The <code>map</code> function is both a consumer and producer of the same channel. This cyclic dependency causes a deadlock. In contrast, Arc-Lang restricts programs such that channels can only be created by instantiating tasks. Once a task is created its inputs cannot change. The output channel of a task cannot end up as an input channel to the same task or any upstream task. This prevents arbitrary cycles from being created in the dataflow graph, and thus prevents deadlocks. Code such as the following will result in a syntax error:</p>
<pre><code><b>task</b> map(i, f): (o) {
    <b>loop</b> {
        o ! f(<b>receive</b> i);
    }
}

<b>def</b> main() {
    <b>val</b> c = map(c, <b>fun</b>(x) = x + <b style="color:darkorange">1</b>);
}</code></pre>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>Operations on streams are by default assumed to succeed without failure, but may also throw <em>exceptions</em> which can be handled by the user. Exceptions are thrown in two scenarios:</p>
<ol>
<li>When receiving data from a channel which has no producer and whose buffer is empty.</li>
<li>When emitting data into a channel which has no consumers.</li>
</ol>
<p>By catching exceptions, tasks can prolong their execution beyond the lifetime of their channels. This is especially useful when tasks have multiple input and output channels, as uncaught exceptions will terminate the task.</p>
<pre><code><b>task</b> producer(xs): (o) {
    <b>for</b> x <b>in</b> xs {
        o ! x;
    }
}

<b>task</b> consumer(i) {
    <b>loop</b> {
        try {
            print(<b>receive</b> i);
        } catch Exception::Receive {
            print(<b style="color:green">"Producer has terminated, therefore I will terminate."</b>);
            <b>return</b>;
        }
    }
}

<b>def</b> main() {
    <b>val</b> stream = producer([<b style="color:darkorange">1</b>,<b style="color:darkorange">2</b>,<b style="color:darkorange">3</b>]);
    consumer(stream);
}</code></pre>
<p>In the above code, a <code>producer</code> task is sending data to a <code>consumer</code> task over a stream. The producer terminates once it is done sending all of its data. Since there are no more tasks which can emit data into the stream (i.e., no more references to the output stream), an exception will be raised when trying to receive data from the input stream.</p>
<pre><code><b>task</b> producer(xs): (o) {
    <b>for</b> x <b>in</b> xs {
        try {
            o ! x;
        } catch Exception::Emit {
            print(<b style="color:green">"Consumer has terminated, therefore I will terminate."</b>);
            <b>return</b>;
        }
    }
}

<b>task</b> consumer(i) {
    <b>for</b> x <b>in</b> i {
        print(x);
        <b>if</b> rand() % <b style="color:darkorange">100</b> == <b style="color:darkorange">0</b> {
            <b>break</b>;
        }
    }
}

<b>def</b> main() {
    <b>val</b> stream = producer([<b style="color:darkorange">1</b>,<b style="color:darkorange">2</b>,<b style="color:darkorange">3</b>]);
    consumer(stream);
}</code></pre>
<p>The above code shows the opposite scenario, where a consumer can potentially terminate and raise an exception at the producer.</p>
<h2 id="flow-control"><a class="header" href="#flow-control">Flow Control</a></h2>
<p>Channels in Arc-Lang are bounded which means that their buffers have a maximum capacity. It is thus important that buffers do not overflow since this would lead to undefined behavior. For example:</p>
<pre><code><b>task</b> producer(): (o) {
    <b>for</b> x <b>in</b> <b style="color:darkorange">0</b>.. {
        o ! x;
    }
}

<b>task</b> consumer(i): () {
    <b>for</b> x <b>in</b> i.. {
        sleep(<b style="color:darkorange">1s</b>);
        print(i);
    }
}

<b>def</b> main() {
    <b>val</b> s = producer();
    consumer(s);
}</code></pre>
<p>In a purely push-based system, the producer would produce data at a faster rate than the consumer can keep up. This would would inevitably cause a buffer overflow in the channel. To prevent such circumstances, a channel will block its producer from pushing events if its buffer is full. Similarly, a channel will block its consumers from pulling events if its buffer is empty. This behavior is implemented by storing multiple queues inside of channels. In particular, each channel has:</p>
<ul>
<li>A <em>push-queue</em> of capacity <code>P</code> which stores promises to push data into the channel as soon as its buffer is not full. The respective producer is blocked until the promise is fulfilled.</li>
<li>A <em>data-queue</em> of capacity <code>N</code> which stores in-flight events.</li>
<li>A <em>pull-queue</em> of capacity <code>C</code> which stores promises to pull data from the channel as soon as its buffer is not empty. The respective consumer is blocked until the promise is fulfilled.</li>
</ul>
<p>We have that <code>P = 1</code> (i.e., a channel can only have one producer), <code>N = &lt;dynamic&gt;</code>, and <code>C = &lt;number of consumers&gt;</code>. Because channels are multicast, all consumers of a channel will pull the same event sequence. To this end, an offset is stored together with each promise in the pull-queue that indicates which event in the data-queue should be pulled. Events can only be evicted from the data-queue if they have been pulled by all consumers.</p>
<h2 id="ordering-of-events"><a class="header" href="#ordering-of-events">Ordering of Events</a></h2>
<p>Tasks are not limited to just one input and output channel. In fact, a task can have a dynamic number of input channels (by for example passing the channels in a vector) and a fixed number of output channels.</p>
<pre><code><b>task</b> merge(s0, s1): (s2) {
    <b>loop</b> {
        s2 ! (<b>receive</b> s0);
        s2 ! (<b>receive</b> s1);
    }
}

<b>def</b> main() {
    <b>val</b> stream0 = <b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>;
    <b>val</b> stream1 = <b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>;
    <b>val</b> stream2 = merge(stream0, stream1);
}</code></pre>
<p>In the above code, <code>merge</code> is a task which can be used to combine events from two channels <code>s0</code> and <code>s1</code> into one <code>s2</code>. By deterministic, we mean the task pulls events from the input channels in a specific order. It is also possible to receive events non-deterministically from a set of channels, as soon as they arrive, using the <code>on</code> syntax:</p>
<pre><code><b>task</b> union(s0, s1): (s2) {
    <b>loop</b> {
        <b>on</b> {
            x <b>in</b> s0 => s2 ! x,
            x <b>in</b> s1 => s2 ! x,
        }
    }
}

<b>def</b> main() {
    <b>val</b> stream0 = <b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>;
    <b>val</b> stream1 = <b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>;
    <b>val</b> stream2 = union(stream0, stream1);
}</code></pre>
<p>In the above code, <code>union</code> is a task which can be used to combine two channels <code>s0</code> and <code>s1</code> non-deterministically into one <code>s2</code>. No ordering guarantees are made between the two channels.</p>
<h2 id="streaming-state"><a class="header" href="#streaming-state">Streaming State</a></h2>
<p>Streaming state is typically exposed explicitly by stream processors. Users need to declare the type of data they want to persistently store and insert read and write operations in their application code to access the state. In Arc-Lang, state is managed implicitly by automatically translating tasks into FSMs (Finite State Machines) that are persisted by the system.</p>
<pre><code><b>task</b> reduce(i, f, init): (o) {
    <b>var</b> state = init;
    <b>for</b> x <b>in</b> i {
        state = f(state, x);
        o ! state;
    }
}

<b>def</b> main() {
    let sum = <b>reduce</b>(<b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>, <b>fun</b>(a, b): a + b, <b style="color:darkorange">0</b>);
    let count = <b>reduce</b>(<b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>, <b>fun</b>(a, _): a + <b style="color:darkorange">1</b>, <b style="color:darkorange">0</b>);
    let max = <b>reduce</b>(<b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>, <b>fun</b>(a, b): <b>if</b> a > b { a } <b>else</b> { b }, <b style="color:darkorange">0</b>);
}</code></pre>
<p>The code above shows a rolling <code>reduce</code> task which reduces a stream using an aggregation function <code>f</code>, beginning at an initial state <code>init</code>.</p>
<p>Note that state is always encapsulated within a task. It is not possible (as of yet) to share state between tasks. Any value sent over a channel is copied from the producer to the consumer. This allows Arc-Lang programs to be parallelised without having to consider the risk of race conditions. How values are copied is abstracted and can for example be deep (for data with interior mutability), shallow (for immutable data), or lazy (copy-on-write). CRDTs and transactional memory are under consideration for enabling shared state.</p>
<h2 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h2>
<p>Tasks and channels enable three forms of parallelism:</p>
<ul>
<li><strong>Pipeline parallelism</strong>: Multiple tasks can pipeline their execution through channels.</li>
<li><strong>Task parallelism</strong>: Multiple tasks can process data from the same channel in parallel.</li>
<li><strong>Data parallelism</strong>: The same task can process data from multiple channels in parallel.</li>
</ul>
<p>An example of pipeline parallelism:</p>
<pre><code><b>task</b> map(i, f): (o) {
    <b>for</b> x <b>in</b> i {
        o ! f(<b>receive</b> x)
    }
}

<b>task</b> filter(i, f): (o) {
    <b>for</b> x <b>in</b> i {
        <b>if</b> f(x) {
            o ! x
        }
    }
}

<b>def</b> pipeline_parallel() {
    <b>val</b> s0 = read_stream();
    <b>val</b> s1 = map(s0, |x| x * <b style="color:darkorange">2</b>);
    <b>val</b> s2 = filter(s1, |x| x % <b style="color:darkorange">2</b> == <b style="color:darkorange">0</b>);
    <i style="color:gray"># ...</i>
}</code></pre>
<p>An example of task parallelism:</p>
<pre><code><b>def</b> task_parallel() {
    <b>val</b> s0 = source(<b style="color:darkorange">0</b>..<b style="color:darkorange">100</b>);
    <b>val</b> s1 = map(s0, |x| x * <b style="color:darkorange">2</b>);
    <b>val</b> s2 = filter(s0, |x| x % <b style="color:darkorange">2</b> == <b style="color:darkorange">0</b>);
    <i style="color:gray"># ...</i>
}</code></pre>
<p>Arc-Lang chooses to make data parallelism implicit since this is the most common form of parallelism. All of the above examples are thus data parallel. The idea of data parallelism is that channels are divided into partitions that can transport events in parallel. Each event has an associated <em>key</em> that determines which partition the event is assigned to. A key can for example be the unique identifier of a sensor that generates data, a location tag, or an article number. Events are required to have a key at the point where they enter the system. It is also possible to change the key of an event. This will be covered in the next section. Note that the method for assigning events to partitions is abstract. This allows Arc-Lang to choose the partitioning approach based on the scenario. Though, currently a static partitioning approach is used. </p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Channels of Arc-Lang are planned to support the following properties:</p>
<ul>
<li><strong>Directions</strong>: Channels can be used to either pull or push data, but not both. Tasks which push data are referred to as &quot;producers&quot; and tasks which pull data are referred to as &quot;consumers&quot;. A task can simultaneously be both a producer and a consumer but not for the same channel.</li>
<li><strong>Bounded</strong>: Channels have a maximum capacity which, when exceeded, will block the producer from pushing events. Similarly, an empty channel will block the consumer from pulling events.</li>
<li><strong>SPMC</strong>: Channels have a single producer and possibly multiple consumers.</li>
<li><strong>Multicast</strong>: All consumers of a channel will pull the same event sequence.</li>
<li><strong>Exceptions</strong>: A channel can be closed by a producer or consumer. When a channel is closed, all tasks waiting on the channel will be notified.</li>
<li><strong>Data parallelism</strong>: A logical channel consists of multiple physical channels which are partitioned using consistent hashing. Data can be transferred over different physical channels in parallel.</li>
<li><strong>Deadlock avoidance</strong>: Channels can only be created by instantiating tasks. The output channel of a task cannot be passed as an input channel to the same task or any upstream task. This prevents arbitrary cycles from being created in the dataflow graph, and thus prevents deadlocks.</li>
<li><strong>Uni-directional</strong>: Channels can only be used to send data in a single direction, i.e., from producer to consumer. Dataflow graphs created through channels and tasks are always directed and acyclic.</li>
<li><strong>Network transparency</strong>: Channels can be used for both local and networked communication. Whether the producer and consumer are on the same machine or on different machines is transparent to the user.</li>
<li><strong>Persistence</strong>: Channels should be able to snapshot their state and replay it from an earlier offset.</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The following restrictions are for now enforced on channels and tasks but may eventually be lifted:</p>
<ul>
<li>Tasks cannot create new tasks. Tasks may only be created by the main-thread of a program. This is because </li>
<li>It is only possible to push and pull events from channels inside of tasks.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tour/basics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../tour/queries.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tour/basics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../tour/queries.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
