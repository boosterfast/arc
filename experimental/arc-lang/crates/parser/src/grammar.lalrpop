use ast::*;
use im_rc::vector;
use im_rc::Vector;
use info::FileId;
use info::ByteIndex;
use info::Spanned;
use diagnostics::Diagnostic;
use lexer::tokens::Token;
use info::Info;
use std::rc::Rc;
use crate::error::parser_error;

//=============================================================================
// Grammar
//=============================================================================

grammar(file_id: FileId, diagnostics: &mut Vec<Diagnostic>);

extern {
    type Error = ();
    type Location = ByteIndex;

    enum Token {
        // Grouping
        "("         =>  Token::ParenL,
        ")"         =>  Token::ParenR,
        "["         =>  Token::BrackL,
        "]"         =>  Token::BrackR,
        "{"         =>  Token::BraceL,
        "}"         =>  Token::BraceR,
        "<"         =>  Token::AngleL,
        ">"         =>  Token::AngleR,
        // Operators
        "!="        =>  Token::Neq,
        "%"         =>  Token::Percent,
        "*"         =>  Token::Star,
        "**"        =>  Token::StarStar,
        "+"         =>  Token::Plus,
        ","         =>  Token::Comma,
        "-"         =>  Token::Minus,
        "."         =>  Token::Dot,
        ".."        =>  Token::DotDot,
        "..="       =>  Token::DotDotEq,
        "/"         =>  Token::Slash,
        ":"         =>  Token::Colon,
        "::"        =>  Token::ColonColon,
        ";"         =>  Token::Semi,
        "<="        =>  Token::Leq,
        ">="        =>  Token::Geq,
        "="         =>  Token::Eq,
        "=="        =>  Token::EqEq,
        "=>"        =>  Token::Imply,
        "_"         =>  Token::Underscore,
        "|"         =>  Token::Bar,
        "@"         =>  Token::AtSign,
        "+="        =>  Token::PlusEq,
        "-="        =>  Token::MinusEq,
        "*="        =>  Token::StarEq,
        "/="        =>  Token::SlashEq,
        "%="        =>  Token::PercentEq,
        "~"         =>  Token::Tilde,
        "!"         =>  Token::Never,
        // Keywords
        "and"       =>  Token::And,
        "as"        =>  Token::As,
        "break"     =>  Token::Break,
        "band"      =>  Token::Band,
        "bor"       =>  Token::Bor,
        "bxor"      =>  Token::Bxor,
        "builtin"   =>  Token::Builtin,
        "case"      =>  Token::Case,
        "catch"     =>  Token::Catch,
        "class"     =>  Token::Class,
        "continue"  =>  Token::Continue,
        "dict"      =>  Token::Dict,
        "do"        =>  Token::Do,
        "def"       =>  Token::Def,
        "desc"      =>  Token::Desc,
        "dyn"       =>  Token::Dyn,
        "else"      =>  Token::Else,
        "extern"    =>  Token::Extern,
        "finally"   =>  Token::Finally,
        "for"       =>  Token::For,
        "from"      =>  Token::From,
        "fun"       =>  Token::Fun,
        "group"     =>  Token::Group,
        "if"        =>  Token::If,
        "in"        =>  Token::In,
        "infix"     =>  Token::Infix,
        "into"      =>  Token::Into,
        "new"       =>  Token::New,
        "instance"  =>  Token::Instance,
        "join"      =>  Token::Join,
        "length"    =>  Token::Length,
        "loop"      =>  Token::Loop,
        "match"     =>  Token::Match,
        "mod"       =>  Token::Mod,
        "not"       =>  Token::Not,
        "on"        =>  Token::On,
        "of"        =>  Token::Of,
        "or"        =>  Token::Or,
        "order"     =>  Token::Order,
        "return"    =>  Token::Return,
        "compute"   =>  Token::Compute,
        "set"       =>  Token::Set,
        "repeat"    =>  Token::Repeat,
        "throw"     =>  Token::Throw,
        "try"       =>  Token::Try,
        "type"      =>  Token::Type,
        "val"       =>  Token::Val,
        "var"       =>  Token::Var,
        "where"     =>  Token::Where,
        "while"     =>  Token::While,
        "window"    =>  Token::Window,
        "use"       =>  Token::Use,
        "xor"       =>  Token::Xor,
        "select"    =>  Token::Select,
        // Identifiers and Literals
        Name        =>  Token::Name(<String>),
        Int         =>  Token::Int(<i128>),
        Float       =>  Token::Float(<f64>),
        IntSuffix   =>  Token::IntSuffix(<(i128, String)>),
        FloatSuffix =>  Token::FloatSuffix(<(f64, String)>),
        Bool        =>  Token::Bool(<bool>),
        Char        =>  Token::Char(<char>),
        "()"        =>  Token::Parens,
        String      =>  Token::String(<String>),
    }
}

Paren<X> = "(" <X> ")";
Brack<X> = "[" <X> "]";
Brace<X> = "{" <X> "}";
Angle<X> = "<" <X> ">";

ParenSeq<X>: Vector<X> = {
    Paren<Seq<X>>,
    "()" => Vector::new(),
}

Error: () = ! => diagnostics.push(parser_error(<>, file_id).into());

#[inline] Epsilon: () = { () }

Fst<A, B> = <A> B;
Snd<A, B> = A <B>;
Split<A, B, C> = <A> B <C>;
Pair<A, B> = A B;

LList<X>: Vector<X> = {
    Epsilon => vector![],
    <mut l:LList<X>> <x:X> => { l.push_back(x); l }
}

NonemptyLList<X>: Vector<X> = {
    X => vector![<>],
    <mut l:NonemptyLList<X>> <x:X> => { l.push_back(x); l }
}

#[inline] SeparatedLList<S, X>: Vector<X> = {
    Epsilon => vector![],
    SeparatedNonemptyLList<S, X>
}

SeparatedNonemptyLList<S, X>: Vector<X> = {
    X => vector![<>],
    <mut l:SeparatedNonemptyLList<S, X>> S <x:X> => { l.push_back(x); l }
}

#[inline] SeparatedLListTrailing<S, X> = <SeparatedLList<S, X>> S?;

#[inline] Seq<X> = SeparatedLListTrailing<",", X>;
#[inline] SeqNonempty<X> = SeparatedNonemptyLList<",", X>;
#[inline] SeqExplicit<X>: Vector<X> = <mut l:SeparatedLList<",", X>> "," <x:X> => { l.push_back(x); l };

Spanned<X>: Spanned<X> = <l:@L> <x:X> <r:@R> => (x, Info::new(file_id, l, r));

#[inline] LOpt<X>: X = {
    Epsilon => Default::default(),
    X,
}

pub(crate) Program = LList<Item>;

Attr = Name (":" <Const>)?;
Decorator = LOpt<Snd<"@", Brace<Seq<Attr>>>>;

Item: Item = Spanned<ItemKind> => Item { kind: Rc::new(<>.0), info: <>.1 };

ItemKind: ItemKind = {
    <Decorator> "from" <Sources> <Brace<QueryStmts>> ";"                                                                => IFrom(<>),
    <Decorator> <Abstract> "def" <DefName> <Generics> <ParenSeq<Type<T0>>> <TypeAnnot?> <LOpt<EffectAnnot>> <Where> ";" => IAbstractDef(<>),
    <Decorator> "def" <DefName> <Generics> <Params> <TypeAnnot?> <Where> <Body<Expr<E0<E16>>>>                          => IDef(<>),
    <Decorator> "type" <Name> <Generics> "=" <Type<T0>> <Where> ";"                                                     => IType(<>),
    <Decorator> <Abstract> "type" <Name> <Generics> <Where> ";"                                                         => IAbstractType(<>),
    <Decorator> "class" <Name> <Generics> <Where> <Brace<Seq<Decl>>> ";"                                                => IClass(<>),
    <Decorator> "instance" <Generics> <Path> <LOpt<Brack<Seq<Type<T0>>>>> <Where> <Brace<Seq<Def>>> ";"                 => IInstance(<>),
    <Decorator> "mod" <Name> <Brace<LList<Item>>> ";"                                                                   => IMod(<>),
    <Decorator> "use" <Path> <UseSuffix?> ";"                                                                           => IUse(<>),
    <Decorator> "val" <Name> <TypeAnnot?> "=" <Expr<E0<E16>>> ";"                                                       => IVal(<>),
}

Abstract: Abstract = {
    "extern" => AExtern,
    "builtin" => ABuiltin
}

Decl = "def" <Name> <Generics> <Params> <TypeAnnot?> <Where> ";";

Def = "def" <Name> <Generics> <Params> <TypeAnnot?> <Where> <Body<Expr<E0<E16>>>>;

Body<E>: Block = {
  "=" <E> => (vector![], Some(<>)),
  <Block>,
}

Effect = Name;

EffectAnnot = Snd<"~", Brace<Seq<Effect>>>;
TypeAnnot = ":" <Type<T0>>;

Params = ParenSeq<Param>;
Param = Pattern<P0>;

Generics = LOpt<Brack<Seq<Generic>>>;
Generic = Name;

Where = LOpt<Snd<"where", Seq<Bound>>>;
Bound = Path Brack<Seq<Type<T0>>>;

Binop: Binop = {
    Op3,
    Op4,
    Op5,
    Op6,
    Op7,
    Op8,
    Op10,
}

Unop = Op9;

DefName: DefName = {
    Name            => DName(<>),
    Unop            => DUnop(<>),
    "infix" <Binop> => DBinop(<>)
}

Index = Int;

#[inline] Path: Path = {
    SeparatedNonemptyLList<"::", Name> => PRel(<>),
    "::" <SeparatedNonemptyLList<"::", Name>> => PAbs(<>),
}

UseSuffix: UseSuffix = {
    "*"             => UGlob,
    Snd<"as", Name> => UAlias(<>),
}

#[inline] Expr<Primary>: Expr = Spanned<Primary> => Expr { kind: Rc::new(<>.0), info: <>.1 };

// Note: This cannot be succeeded by a brace 
E0<Primary>: ExprKind = {
    "from" <Sources> <Brace<QueryStmts>> => EFrom(<>),
    "return" <Expr<E1<Primary>>?>     => EReturn(<>),
    "break" <Expr<E1<Primary>>?>      => EBreak(<>),
    "continue"                        => EContinue,
    "throw" <Expr<E1<Primary>>>       => EThrow(<>),
    E1<Primary>,
}

// Note: This cannot be succeeded by a brace 
E1<Primary>: ExprKind = {
    "fun" <Params> <TypeAnnot?> <Body<Expr<E1<E17>>>> => EFunc(<>),
    E2<Primary>,
}
  
Op2: Binop = {
    "="        => BMut,
    "+="       => BAdd,
    "-="       => BSub,
    "*="       => BMul,
    "/="       => BDiv,
    "%="       => BMod,
    "in"       => BIn,
    "not" "in" => BNotIn,
}

E2<Primary>: ExprKind = {
    Expr<E2<Primary>> Op2 Expr<E3<Primary>> => EBinop(<>),
    E3<Primary>,
}

Op3: Binop = {
    ".." => BRExc,
    "..=" => BRInc,
}
E3<Primary>: ExprKind = {
    Expr<E4<Primary>> Op3 Expr<E4<Primary>> => EBinop(<>),
    E4<Primary>,
}
  
Op4: Binop = {
    "bor" => BBor,
    "band" => BBand,
    "bxor" => BBxor,
    "or" => BOr,
    "xor" => BXor,
    "and" => BAnd,
}
E4<Primary>: ExprKind = {
    Expr<E4<Primary>> Op4 Expr<E5<Primary>> => EBinop(<>),
    E5<Primary>,
}

Op5: Binop = {
    "==" => BEq,
    "!=" => BNeq,
}
E5<Primary>: ExprKind = {
    Expr<E5<Primary>> Op5 Expr<E6<Primary>> => EBinop(<>),
    E6<Primary>,
}

Op6: Binop = {
    "<" => BLt,
    ">" => BGt,
    "<=" => BLeq,
    ">=" => BGeq,
}
E6<Primary>: ExprKind = {
    Expr<E6<Primary>> Op6 Expr<E7<Primary>> => EBinop(<>),
    E7<Primary>,
}

Op7: Binop = {
    "+" => BAdd,
    "-" => BSub,
    "%" => BMod,
}
E7<Primary>: ExprKind = {
    Expr<E7<Primary>> Op7 Expr<E8<Primary>> => EBinop(<>),
    E8<Primary>,
}
  
Op8: Binop = {
    "*" => BMul,
    "/" => BDiv,
}
E8<Primary>: ExprKind = {
    Expr<E8<Primary>> Op8 Expr<E9<Primary>> => EBinop(<>),
    E9<Primary>,
}

Op9: Unop = {
    "not" => UNot,
    "-" => UNeg,
}
E9<Primary>: ExprKind = {
    Op9 Expr<E9<Primary>> => EUnop(<>),
    E10<Primary>,
}

Op10: Binop = {
    "**" => BPow,
}
E10<Primary>: ExprKind = {
    Expr<E11<Primary>> Op10 Expr<E10<Primary>> => EBinop(<>),
    E11<Primary>,
}

E11<Primary>: ExprKind = {
    <Expr<E11<Primary>>> ":" <Type<T0>> => EAnnot(<>),
    E12<Primary>,
}

E12<Primary>: ExprKind = {
    E13<Primary>,
}

E13<Primary>: ExprKind = {
    E14<Primary>,
    E15<Primary>,
}

E14<Primary>: ExprKind = {
    Expr<Primary> ParenSeq<Expr<E1<E16>>> => ECall(<>),
    Primary,
}

// TODO: Named arguments 
// Arg: Arg = {
//     Name ":" Expr<E1<E16>> => ANamed(<>), 
//     Expr<E1<E16>>          => APos(<>), 
// }

E15<Primary>: ExprKind = {
    <Expr<E13<Primary>>> "." <Index>                          => EAccessTuple(<>),
    <Expr<E13<Primary>>> "." <Name>                           => EAccessRecord(<>),
    <Expr<E13<Primary>>> <Brack<Seq<Expr<E1<Primary>>>>>      => EAccessArray(<>),
    <Expr<E13<Primary>>> "." <Brace<Seq<Name>>>               => EAccessRecordMulti(<>),
    <Expr<E13<Primary>>> "." <Name> <ParenSeq<Expr<E1<E16>>>> => ECallItem(<>),
}

// These may not be followed by a braceThis could allow `if Foo { ... } else { ... }`
// to be parsed as `if <Ident> { ... } else { ... }`
E16: ExprKind = {
    "new" <Variant<Expr<E16>>> => EVariant(<>.0, <>.1),
    //<Expr<E16>> "{" "}" => todo!(),
    E17
}

ExprRecord = Brace<Pair<Seq<ExprField>, Tail<Expr<E1<E16>>>?>>;
ExprField: ExprField = {
    Name Snd<":", Expr<E1<E16>>>? => FName(<>),
    <Expr<E13<E16>>> "." <Name>   => FExpr(<>),
}

Dict<A, B> = Brace<SeqNonempty<Pair<A, Snd<":", B>>>>;
Set<A> = Brace<SeqNonempty<A>>;

TypeRecord = Brace<Pair<Seq<TypeField>, Tail<Type<T0>>?>>;
TypeField = Pair<Name, Snd<":", Type<T0>>?>;

PatRecord = Brace<Pair<Seq<PatField>, Tail<Pattern<P0>>?>>;
PatField = Pair<Name, Snd<":", Pattern<P0>>?>;

ExprDynRecord = <Brace<SeqNonempty<ExprDynField>>>;
ExprDynField = Expr<E17> Snd<":", Expr<E1<E16>>>;

E17: ExprKind = {
    Paren<E1<E16>>,
    Lit                                                                        => ELit(<>),
    Path LOpt<Qualify<Seq<Type<T0>>>>                                          => EPath(<>),
    Array<Expr<E1<E16>>>                                                       => EArray(<>.0, <>.1),
    Tuple<Expr<E1<E16>>>                                                       => ETuple(<>),
    ExprRecord                                                                 => ERecord(<>.0, <>.1),
    "dyn" <ExprDynRecord>                                                      => EDynRecord(<>),
    "_"                                                                        => EAnon,
    "do" <Block>                                                               => EDo(<>),
    "dict" <Dict<Expr<E17>, Expr<E1<E16>>>>                                    => EDict(<>),
    "set" <Set<Expr<E1<E16>>>>                                                 => ESet(<>),
    "if" <Expr<E2<E17>>> <Block> <Snd<"else", Block>?>                         => EIf(<>),
    "if" "val" <Pattern<P0>> "=" <Expr<E2<E17>>> <Block> <Snd<"else", Block>?> => EIfVal(<>),
    "match" <Expr<E2<E17>>> <Brace<Arms>>                                      => EMatch(<>),
    "loop" <Block>                                                             => ELoop(<>),
    "while" <Expr<E2<E17>>> <Block>                                            => EWhile(<>),
    "while" "val" <Pattern<P0>> "=" <Expr<E2<E17>>> <Block>                    => EWhileVal(<>),
    "for" <Pattern<P0>> "in" <Expr<E2<E17>>> <Block>                           => EFor(<>),
    "try" <Block> "catch" <Brace<Arms>> <Snd<"finally", Block>?>               => ETry(<>),
    Error                                                                      => EError,
}

Sources = SeparatedNonemptyLList<",", Source>;
Source = Pattern<P0> SourceKind Expr<E1<E17>>;
SourceKind: SourceKind = {
    "in" => ScIn,
    "=" => ScEq,
}

QueryStmts = NonemptyLList<QueryStmt>;
QueryStmt: QueryStmt = {
    "where" <e:Expr<E1<E16>>> => SWhere {<>},
    "join" <args:Seq<Split<Pattern<P0>, "in", Expr<E1<E17>>>>> <e:Snd<"on", Expr<E1<E16>>>> => SJoin {<>},
    "group" <es:SeqNonempty<Expr<E1<E16>>>> <alias:Snd<"as", Name>> => SGroup {<>},
    "window" <arg:Expr<E1<E16>>> <alias:Snd<"as", Name>>
      "{"
        <length:Snd<"length", Expr<E1<E16>>>>
        <repeat:Snd<"repeat", Expr<E1<E16>>>?>
        <aggrs:Snd<"compute", Aggrs>>
      "}" => SWindow {<>},
    "compute" <aggrs:Aggrs> => SCompute {<>},
    "order" <orders:SeqNonempty<Pair<Expr<E1<E16>>, Order>>> => SOrder {<>},
    "select" <e:Expr<E1<E16>>> => SSelect {<>},
    "into" <e:Expr<E1<E16>>> => SInto {<>},
}

Aggrs = SeqNonempty<Aggr>;
Aggr = Expr<E1<E16>> Snd<"of", Expr<E1<E16>>>? Snd<"as", Name>;

Order: Order = {
    Epsilon => OAsc,
    "desc" => ODesc,
}

Qualify<X> = "::" <Brack<X>>;
Tail<X> = "|" <X>;

Arms = SeqNonempty<Arm>;
Arm = <Pattern<P0>> "=>" <Expr<E1<E16>>>;

Block = Brace<Pair<Stmts, Expr<E1<E16>>?>>;

#[inline] Stmts = LList<Stmt>;
Stmt: Stmt = {
    ";"                                               => SNoop,
    <Expr<E0<E16>>> ";"                               => SExpr(<>),
    "val" <Param> "=" <Expr<E0<E16>>> ";"             => SVal(<>),
    "var" <Name> <TypeAnnot?> "=" <Expr<E0<E16>>> ";" => SVar(<>),
}

Pattern<P>: Pattern = Spanned<P> => Pattern { kind: Rc::new(<>.0), info: <>.1 };

P0: PatternKind = {
    <Pattern<P0>> "or" <Pattern<P1>> => POr(<>),
    <Pattern<P0>> ":" <Type<T0>>     => PAnnot(<>),
    P1
}
  
P1: PatternKind = {
    Const                       => PConst(<>),
    Name                        => PVar(<>),
    "case" <Name> <Pattern<P1>> => PVariant(<>),
    Tuple<Pattern<P0>>          => PTuple(<>),
    PatRecord                   => PRecord(<>.0, <>.1),
    Array<Pattern<P0>>          => PArray(<>.0, <>.1),
    "_"                         => PIgnore,
    Error                       => PError,
}

Type<T>: Type = Spanned<T> => Type { kind: Rc::new(<>.0), info: <>.1 };

T0: TypeKind = {
    "fun" <ParenSeq<Type<T0>>> ":" <Type<T0>> => TFunc(<>),
    T1
}

T1: TypeKind = {
    Path LOpt<Brack<SeqNonempty<Type<T0>>>> => TPath(<>),
    Tuple<Type<T0>>                         => TTuple(<>),
    TypeRecord                              => TRecord(<>.0, <>.1),
    Enum<Type<T0>>                          => TEnum(<>.0, <>.1),
    Brack<Type<T0>>                         => TArray(<>),
    "()"                                    => TUnit,
    "!"                                     => TNever,
    Error                                   => TError,
}

Array<X> = Brack<Pair<Seq<X>, Tail<X>?>>;
Tuple<X> = Paren<SeqExplicit<X>>;
Enum<X> = Angle<Pair<Seq<Variant<Type<T0>>>, Tail<X>?>>;
Variant<X> = Name X;

Lit: Lit = {
    Bool        => LBool(<>),
    Char        => LChar(<>),
    Int         => LInt(<>, None),
    IntSuffix   => LInt(<>.0, Some(<>.1)),
    Float       => LFloat(<>, None),
    FloatSuffix => LFloat(<>.0, Some(<>.1)),
    "()"        => LUnit,
    String      => LString(<>),
}

Const: Const = {
    Bool   => CBool(<>),
    Char   => CChar(<>),
    Int    => CInt(<>),
    Float  => CFloat(<>),
    "()"   => CUnit,
    String => CString(<>),
}
